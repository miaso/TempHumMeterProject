Disassembly Listing for picTest
Generated From:
C:/Users/IdeaPad/MPLABXProjects/picTest.X/dist/default/debug/picTest.X.debug.elf
10-03-2016 14:12:46

---  C:/Users/IdeaPad/MPLABXProjects/picTest.X/uart1.c  -------------------------------------------------
1:                 /*
2:                  * File:   uart1.c
3:                  * Author: IdeaPad
4:                  *
5:                  * Created on 1. marts 2016, 13:03
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                
11:                #include "uart1.h"
12:                #include "extralDefines.h"
13:                
14:                //Initiation function
15:                //parameter BAUDRATEREG1 determines baud speed
16:                void UART1Init(int BAUDRATEREG1)
17:                {
001CE6  FA0002     LNK #0x2
001CE8  780F00     MOV W0, [W14]
18:                    uart1rx_trs=1;
001CEA  A8A2D8     BSET TRISD, #5
19:                   //Set up registers
20:                   U1BRG = BAUDRATEREG1;	//set baud speed
001CEC  78001E     MOV [W14], W0
001CEE  881140     MOV W0, U1BRG
21:                   U1MODE	=	0x8000;	 //turn on module
001CF0  280000     MOV #0x8000, W0
001CF2  881100     MOV W0, U1MODE
22:                   U1STA	=	0x8400;	 //set interrupts
001CF4  284000     MOV #0x8400, W0
001CF6  881110     MOV W0, U1STA
23:                   //reset RX interrupt flag
24:                   IFS0bits.U1RXIF = 0;
001CF8  A96085     BCLR 0x85, #3
25:                }
001CFA  FA8000     ULNK
001CFC  060000     RETURN
001CFE  FA0002     LNK #0x2
001D00  784F00     MOV.B W0, [W14]
001D02  000000     NOP
001D04  801111     MOV U1STA, W1
001D06  202000     MOV #0x200, W0
001D08  608000     AND W1, W0, W0
001D0A  E00000     CP0 W0
001D0C  3AFFFB     BRA NZ, 0x1D04
001D0E  FB001E     SE [W14], W0
001D10  881120     MOV W0, U1TXREG
001D12  FA8000     ULNK
001D14  060000     RETURN
001D16  FA0004     LNK #0x4
001D18  980710     MOV W0, [W14+2]
001D1A  EB4000     CLR.B W0
001D1C  784F00     MOV.B W0, [W14]
001D1E  370006     BRA 0x1D2C
001D20  90001E     MOV [W14+2], W0
001D22  784010     MOV.B [W0], W0
001D24  07FFEC     RCALL UART1PutChar
001D26  90001E     MOV [W14+2], W0
001D28  E80000     INC W0, W0
001D2A  980710     MOV W0, [W14+2]
001D2C  90001E     MOV [W14+2], W0
001D2E  784F10     MOV.B [W0], [W14]
001D30  78401E     MOV.B [W14], W0
001D32  E00400     CP0.B W0
001D34  3AFFF5     BRA NZ, 0x1D20
001D36  FA8000     ULNK
001D38  060000     RETURN
001D3A  FA0002     LNK #0x2
001D3C  000000     NOP
001D3E  800421     MOV IFS0, W1
001D40  208000     MOV #0x800, W0
001D42  608000     AND W1, W0, W0
001D44  E00000     CP0 W0
001D46  32FFFB     BRA Z, 0x1D3E
001D48  801130     MOV U1RXREG, W0
001D4A  784F00     MOV.B W0, [W14]
001D4C  A96085     BCLR 0x85, #3
001D4E  78401E     MOV.B [W14], W0
001D50  FA8000     ULNK
001D52  060000     RETURN
26:                
27:                //UART transmit function, parameter Ch is the character to send
28:                void UART1PutChar(char Ch)
29:                {
001CFE  FA0002     LNK #0x2
30:                   //transmit ONLY if TX buffer is empty
31:                   while(U1STAbits.UTXBF == 1);
001D02  000000     NOP
001D04  801111     MOV U1STA, W1
001D06  202000     MOV #0x200, W0
001D08  608000     AND W1, W0, W0
001D0A  E00000     CP0 W0
001D0C  3AFFFB     BRA NZ, 0x1D04
32:                   U1TXREG = Ch;
001D0E  FB001E     SE [W14], W0
001D10  881120     MOV W0, U1TXREG
33:                }
001D12  FA8000     ULNK
001D14  060000     RETURN
34:                
35:                void UART1PutStr(char* s){
001D16  FA0004     LNK #0x4
001D18  980710     MOV W0, [W14+2]
36:                    	char c = 0;
001D1A  EB4000     CLR.B W0
001D1C  784F00     MOV.B W0, [W14]
37:                        for (;(( c=*s)!=0);s++){
001D1E  370006     BRA 0x1D2C
001D26  90001E     MOV [W14+2], W0
001D28  E80000     INC W0, W0
001D2A  980710     MOV W0, [W14+2]
001D2C  90001E     MOV [W14+2], W0
001D2E  784F10     MOV.B [W0], [W14]
001D30  78401E     MOV.B [W14], W0
001D32  E00400     CP0.B W0
001D34  3AFFF5     BRA NZ, 0x1D20
38:                		UART1PutChar(*s); 
001D20  90001E     MOV [W14+2], W0
001D22  784010     MOV.B [W0], W0
001D24  07FFEC     RCALL UART1PutChar
39:                	}
40:                }
001D36  FA8000     ULNK
001D38  060000     RETURN
41:                
42:                //UART receive function, returns the value received.
43:                char UART1GetChar()
44:                {
001D3A  FA0002     LNK #0x2
45:                   char Temp;
46:                   //wait for buffer to fill up, wait for interrupt
47:                   while(IFS0bits.U1RXIF == 0);
001D3C  000000     NOP
001D3E  800421     MOV IFS0, W1
001D40  208000     MOV #0x800, W0
001D42  608000     AND W1, W0, W0
001D44  E00000     CP0 W0
001D46  32FFFB     BRA Z, 0x1D3E
48:                   Temp = U1RXREG;
001D48  801130     MOV U1RXREG, W0
001D4A  784F00     MOV.B W0, [W14]
49:                   //reset interrupt
50:                   IFS0bits.U1RXIF = 0;
001D4C  A96085     BCLR 0x85, #3
51:                   //return my received byte
52:                   return Temp;
001D4E  78401E     MOV.B [W14], W0
53:                }
001D50  FA8000     ULNK
001D52  060000     RETURN
001D54  FA0004     LNK #0x4
1:                 #include "extralDefines.h"
2:                 #include "spiDriver.h"
3:                 /******************************************************************************/
4:                 // global variables
5:                 /******************************************************************************/
6:                 
7:                 
8:                 /******************************************************************************/
9:                 // local variables
10:                /******************************************************************************/
11:                volatile uint16_t eepromIndex;
12:                
13:                uint16_t writeAddressCheck;
14:                
15:                uint16_t bytesToWrite0;
16:                uint16_t bytesToWrite1;
17:                
18:                /******************************************************************************/
19:                // transfer one byte over SPI
20:                /******************************************************************************/
21:                uint8_t spiTransferByte(uint8_t data)
22:                {
001D54  FA0004     LNK #0x4
001D56  984720     MOV.B W0, [W14+2]
23:                    uint8_t receivedByte;
24:                
25:                    while(SPI1_TX_BUFFER_FULL);
001D58  000000     NOP
001D5A  801200     MOV SPI1STAT, W0
001D5C  600062     AND W0, #0x2, W0
001D5E  E00000     CP0 W0
001D60  3AFFFC     BRA NZ, 0x1D5A
26:                    SPI1_INTERRUPT_CLEAR;
001D62  A94085     BCLR 0x85, #2
27:                    SPI1_FAULT_CLEAR;
001D64  A92085     BCLR 0x85, #1
28:                    SPI1_OVERFLOW_CLEAR;
001D66  A9C240     BCLR SPI1STAT, #6
29:                    SPI1BUF = data; 
001D68  90402E     MOV.B [W14+2], W0
001D6A  FB8000     ZE W0, W0
001D6C  881240     MOV W0, SPI1BUF
30:                    while(!SPI1_RX_BUFFER_FULL);
001D6E  000000     NOP
001D70  801200     MOV SPI1STAT, W0
001D72  600061     AND W0, #0x1, W0
001D74  E00000     CP0 W0
001D76  32FFFC     BRA Z, 0x1D70
31:                    receivedByte = SPI1BUF;
001D78  801240     MOV SPI1BUF, W0
001D7A  784F00     MOV.B W0, [W14]
32:                
33:                    return receivedByte;
001D7C  78401E     MOV.B [W14], W0
34:                }
001D7E  FA8000     ULNK
001D80  060000     RETURN
35:                /******************************************************************************/
36:                // transfer one byte over SPI2
37:                /******************************************************************************/
38:                uint8_t spi2TransferByte(uint8_t data)
39:                {
001D82  FA0004     LNK #0x4
001D84  984720     MOV.B W0, [W14+2]
40:                    uint8_t receivedByte;
41:                
42:                    while(SPI2_TX_BUFFER_FULL);
001D86  000000     NOP
001D88  801300     MOV SPI2STAT, W0
001D8A  600062     AND W0, #0x2, W0
001D8C  E00000     CP0 W0
001D8E  3AFFFC     BRA NZ, 0x1D88
43:                    SPI2_INTERRUPT_CLEAR;
001D90  A92088     BCLR IFS2, #1
44:                    SPI2_FAULT_CLEAR;
001D92  A90088     BCLR IFS2, #0
45:                    SPI2_OVERFLOW_CLEAR;
001D94  A9C260     BCLR SPI2STAT, #6
46:                    SPI2BUF = data; 
001D96  90402E     MOV.B [W14+2], W0
001D98  FB8000     ZE W0, W0
001D9A  881340     MOV W0, SPI2BUF
47:                    while(!SPI2_RX_BUFFER_FULL);
001D9C  000000     NOP
001D9E  801300     MOV SPI2STAT, W0
001DA0  600061     AND W0, #0x1, W0
001DA2  E00000     CP0 W0
001DA4  32FFFC     BRA Z, 0x1D9E
48:                    receivedByte = SPI2BUF;
001DA6  801340     MOV SPI2BUF, W0
001DA8  784F00     MOV.B W0, [W14]
49:                
50:                    return receivedByte;
001DAA  78401E     MOV.B [W14], W0
51:                }
001DAC  FA8000     ULNK
001DAE  060000     RETURN
001DB0  FA0004     LNK #0x4
---  C:/Users/IdeaPad/MPLABXProjects/picTest.X/si7020.c  ------------------------------------------------
1:                 #include "xc.h"
2:                 #define FCY     16000000ULL //TO DO
3:                 #include "i2c1.h"
4:                 #include "uart1.h"
5:                 
6:                 #include <libpic30.h>
7:                 #include "extralDefines.h"
8:                 
9:                 
10:                
11:                
12:                
13:                
14:                // For Manual: Needs Details
15:                // When PIC clock increase past 1MHz, will need to update these delays
16:                #define Delay_Bus_Free_Time		{ __delay_us(2) }		// minimum 1.3us
17:                #define Delay_Start_Hold_Time	{ __delay_us(1) }				// minimum 600 nano sec
18:                #define Delay_SCL				{ __delay_us(2) }				// maximum 400kHz period, thus 2.5us / 2
19:                #define Delay_Stop_Hold_Time	{ __delay_us(1) }				// minimum 50ns
20:                //--------------------------------------------------------------
21:                
22:                
23:                unsigned TempBit0,I2C_DataByteH,I2C_DataByteL ;
24:                
25:                
26:                
27:                void INITIALIZE_SI7020(void){
001650  FA0000     LNK #0x0
28:                    I2C_SCL_TRS = 0;
001652  A942F0     BCLR TRISG, #2
29:                    I2C_SDA_TRS = 0;
001654  A962F0     BCLR TRISG, #3
30:                }
001656  FA8000     ULNK
001658  060000     RETURN
31:                
32:                // For Manual: Needs Details
33:                void I2C_StopBit(void)
34:                {
00165A  FA0000     LNK #0x0
35:                	I2C_SCL_L;
00165C  A842F4     BSET LATG, #2
36:                	I2C_SDA_L;
00165E  A862F4     BSET LATG, #3
37:                	Delay_SCL;
001660  200200     MOV #0x20, W0
001662  200001     MOV #0x0, W1
001664  0703E8     RCALL ___delay32
38:                	I2C_SCL_HF;
001666  A942F4     BCLR LATG, #2
39:                	I2C_SDA_L;
001668  A862F4     BSET LATG, #3
40:                	Delay_Stop_Hold_Time;
00166A  200100     MOV #0x10, W0
00166C  200001     MOV #0x0, W1
00166E  0703E3     RCALL ___delay32
41:                	I2C_SCL_HF;
001670  A942F4     BCLR LATG, #2
42:                	I2C_SDA_HF;
001672  A962F4     BCLR LATG, #3
43:                }
001674  FA8000     ULNK
001676  060000     RETURN
44:                
45:                //--------------------------------------------------------------
46:                // For Manual: Needs Details
47:                void I2C_StartBit(void)
48:                {
001678  FA0000     LNK #0x0
49:                    
50:                	I2C_SCL_HF;
00167A  A942F4     BCLR LATG, #2
51:                	I2C_SDA_HF;
00167C  A962F4     BCLR LATG, #3
52:                	Delay_Bus_Free_Time;
00167E  200200     MOV #0x20, W0
001680  200001     MOV #0x0, W1
001682  0703D9     RCALL ___delay32
53:                	I2C_SCL_HF;
001684  A942F4     BCLR LATG, #2
54:                	I2C_SDA_L;
001686  A862F4     BSET LATG, #3
55:                	Delay_Start_Hold_Time;
001688  200100     MOV #0x10, W0
00168A  200001     MOV #0x0, W1
00168C  0703D4     RCALL ___delay32
56:                	I2C_SCL_L;
00168E  A842F4     BSET LATG, #2
57:                	I2C_SDA_HF; // Release Data Line
001690  A962F4     BCLR LATG, #3
58:                }
001692  FA8000     ULNK
001694  060000     RETURN
59:                
60:                #define Si7020Address	0x40
61:                #define SlaveRead		0x01
62:                #define SlaveWrite		0x00
63:                
64:                unsigned char TempUChar01,TempUChar02;
65:                //--------------------------------------------------------------
66:                // For Manual: Needs Details
67:                //void I2C_ReadByte( unsigned char Read0Write1, unsigned char NACKorACK)
68:                unsigned char I2C_SlaveAddressAnd( unsigned char Mode)
69:                {
001696  FA0002     LNK #0x2
001698  784F00     MOV.B W0, [W14]
70:                	TempUChar01 = 0;
00169A  EF688C     CLR.B TempUChar01
71:                	TempUChar02 = Si7020Address;
00169C  B3C400     MOV.B #0x40, W0
00169E  B7E88D     MOV.B WREG, TempUChar02
72:                	if (Mode == SlaveRead)
0016A0  78401E     MOV.B [W14], W0
0016A2  504FE1     SUB.B W0, #0x1, [W15]
0016A4  3A0004     BRA NZ, 0x16AE
73:                		TempUChar02 |= SlaveRead;
0016A6  BFC88D     MOV.B TempUChar02, WREG
0016A8  A00400     BSET.B W0, #0
0016AA  B7E88D     MOV.B WREG, TempUChar02
74:                	else
75:                		TempUChar02 &= 0b11111110;
0016AE  2088D1     MOV #0x88D, W1
0016B0  784091     MOV.B [W1], W1
0016B2  B3CFE0     MOV.B #0xFE, W0
0016B4  60C000     AND.B W1, W0, W0
0016B6  B7E88D     MOV.B WREG, TempUChar02
76:                	while (TempUChar01<8)
0016AC  37001A     BRA 0x16E2
0016B8  370014     BRA 0x16E2
0016E2  BFC88C     MOV.B TempUChar01, WREG
0016E4  504FE7     SUB.B W0, #0x7, [W15]
0016E6  36FFE9     BRA LEU, 0x16BA
77:                	{
78:                		if (TempUChar02&0b10000000)
0016BA  BFC88D     MOV.B TempUChar02, WREG
0016BC  E00400     CP0.B W0
0016BE  3D0002     BRA GE, 0x16C4
79:                			{ I2C_SDA_HF; }
0016C0  A962F4     BCLR LATG, #3
0016C2  370001     BRA 0x16C6
80:                		else
81:                			{ I2C_SDA_L; }
0016C4  A862F4     BSET LATG, #3
82:                		TempUChar02 <<= 1;
0016C6  BFC88D     MOV.B TempUChar02, WREG
0016C8  404000     ADD.B W0, W0, W0
0016CA  B7E88D     MOV.B WREG, TempUChar02
83:                		Delay_SCL;
0016CC  200200     MOV #0x20, W0
0016CE  200001     MOV #0x0, W1
0016D0  0703B2     RCALL ___delay32
84:                		I2C_SCL_HF;
0016D2  A942F4     BCLR LATG, #2
85:                		Delay_SCL;
0016D4  200200     MOV #0x20, W0
0016D6  200001     MOV #0x0, W1
0016D8  0703AE     RCALL ___delay32
86:                		I2C_SCL_L;
0016DA  A842F4     BSET LATG, #2
87:                		TempUChar01++;
0016DC  BFC88C     MOV.B TempUChar01, WREG
0016DE  E84000     INC.B W0, W0
0016E0  B7E88C     MOV.B WREG, TempUChar01
88:                	}
89:                	I2C_SDA_HF; // Release Data Line
0016E8  A962F4     BCLR LATG, #3
90:                }
0016EA  FA8000     ULNK
0016EC  060000     RETURN
91:                
92:                #define SlaveACK	0
93:                #define SlaveNACK	1
94:                //--------------------------------------------------------------
95:                // For Manual: Needs Details
96:                unsigned char SlaveReponse(void)
97:                {
0016EE  FA0000     LNK #0x0
98:                	Delay_SCL;
0016F0  200200     MOV #0x20, W0
0016F2  200001     MOV #0x0, W1
0016F4  0703A0     RCALL ___delay32
99:                	I2C_SCL_HF;
0016F6  A942F4     BCLR LATG, #2
100:               	Delay_SCL;
0016F8  200200     MOV #0x20, W0
0016FA  200001     MOV #0x0, W1
0016FC  07039C     RCALL ___delay32
101:               	while (I2C_SCL_State == 0); // Slave Clock Stretching
0016FE  000000     NOP
001700  8017A0     MOV LATG, W0
001702  600064     AND W0, #0x4, W0
001704  E00000     CP0 W0
001706  32FFFC     BRA Z, 0x1700
102:               	TempBit0 = I2C_SDA_State;
001708  8017A0     MOV LATG, W0
00170A  DE0043     LSR W0, #3, W0
00170C  604061     AND.B W0, #0x1, W0
00170E  FB8000     ZE W0, W0
001710  884430     MOV W0, TempBit0
103:               	I2C_SCL_L;
001712  A842F4     BSET LATG, #2
104:               	if (TempBit0)
001714  804430     MOV TempBit0, W0
001716  E00000     CP0 W0
001718  320002     BRA Z, 0x171E
105:               		return (1);
00171A  B3C010     MOV.B #0x1, W0
00171C  370001     BRA 0x1720
106:               	else
107:               		return (0);
00171E  EB4000     CLR.B W0
108:               }
001720  FA8000     ULNK
001722  060000     RETURN
109:               
110:               //--------------------------------------------------------------
111:               // For Manual: Needs Details
112:               void I2C_SendByte(unsigned char ByteToSend)
113:               {
001724  FA0002     LNK #0x2
001726  784F00     MOV.B W0, [W14]
114:               	TempUChar01 = 0;
001728  EF688C     CLR.B TempUChar01
115:               	while (TempUChar01<8)
00172A  370014     BRA 0x1754
001754  BFC88C     MOV.B TempUChar01, WREG
001756  504FE7     SUB.B W0, #0x7, [W15]
001758  36FFE9     BRA LEU, 0x172C
116:               	{
117:               		if (ByteToSend&0b10000000)
00172C  78401E     MOV.B [W14], W0
00172E  E00400     CP0.B W0
001730  3D0002     BRA GE, 0x1736
118:               			{ I2C_SDA_HF; }
001732  A962F4     BCLR LATG, #3
001734  370001     BRA 0x1738
119:               		else
120:               			{ I2C_SDA_L; }
001736  A862F4     BSET LATG, #3
121:               		ByteToSend <<= 1;
001738  78401E     MOV.B [W14], W0
00173A  404000     ADD.B W0, W0, W0
00173C  784F00     MOV.B W0, [W14]
122:               		Delay_SCL;
00173E  200200     MOV #0x20, W0
001740  200001     MOV #0x0, W1
001742  070379     RCALL ___delay32
123:               		I2C_SCL_HF;
001744  A942F4     BCLR LATG, #2
124:               		Delay_SCL;
001746  200200     MOV #0x20, W0
001748  200001     MOV #0x0, W1
00174A  070375     RCALL ___delay32
125:               		I2C_SCL_L;
00174C  A842F4     BSET LATG, #2
126:               		TempUChar01++;
00174E  BFC88C     MOV.B TempUChar01, WREG
001750  E84000     INC.B W0, W0
001752  B7E88C     MOV.B WREG, TempUChar01
127:               	}
128:               	I2C_SDA_HF; // Release Data Line
00175A  A962F4     BCLR LATG, #3
129:               }
00175C  FA8000     ULNK
00175E  060000     RETURN
001760  FA0002     LNK #0x2
001762  784F00     MOV.B W0, [W14]
130:               
131:               #define MasterACK	0
132:               #define MasterNACK	1
133:               //--------------------------------------------------------------
134:               // For Manual: Needs Details
135:               unsigned char I2C_GetByte(unsigned char MasterResponse)
136:               {
001760  FA0002     LNK #0x2
137:               	I2C_SDA_HF; // Release Data Line
001764  A962F4     BCLR LATG, #3
138:               	TempUChar01 = 0;
001766  EF688C     CLR.B TempUChar01
139:               	while (TempUChar01<8)
001768  37001B     BRA 0x17A0
0017A0  BFC88C     MOV.B TempUChar01, WREG
0017A2  504FE7     SUB.B W0, #0x7, [W15]
0017A4  36FFE2     BRA LEU, 0x176A
140:               	{
141:               		Delay_SCL;
00176A  200200     MOV #0x20, W0
00176C  200001     MOV #0x0, W1
00176E  070363     RCALL ___delay32
142:               		I2C_SCL_HF;
001770  A942F4     BCLR LATG, #2
143:               		Delay_SCL;
001772  200200     MOV #0x20, W0
001774  200001     MOV #0x0, W1
001776  07035F     RCALL ___delay32
144:               		if (I2C_SDA_State==1)
001778  8017A0     MOV LATG, W0
00177A  600068     AND W0, #0x8, W0
00177C  E00000     CP0 W0
00177E  320004     BRA Z, 0x1788
145:               			TempUChar02 |= 0b00000001;
001780  BFC88D     MOV.B TempUChar02, WREG
001782  A00400     BSET.B W0, #0
001784  B7E88D     MOV.B WREG, TempUChar02
001786  370005     BRA 0x1792
146:               		else
147:               			TempUChar02 &= 0b11111110;
001788  2088D1     MOV #0x88D, W1
00178A  784091     MOV.B [W1], W1
00178C  B3CFE0     MOV.B #0xFE, W0
00178E  60C000     AND.B W1, W0, W0
001790  B7E88D     MOV.B WREG, TempUChar02
148:               		TempUChar02 <<= 1;
001792  BFC88D     MOV.B TempUChar02, WREG
001794  404000     ADD.B W0, W0, W0
001796  B7E88D     MOV.B WREG, TempUChar02
149:               		I2C_SCL_L;
001798  A842F4     BSET LATG, #2
150:               		TempUChar01++;
00179A  BFC88C     MOV.B TempUChar01, WREG
00179C  E84000     INC.B W0, W0
00179E  B7E88C     MOV.B WREG, TempUChar01
151:               	}
152:               	Delay_SCL;
0017A6  200200     MOV #0x20, W0
0017A8  200001     MOV #0x0, W1
0017AA  070345     RCALL ___delay32
153:               	if (MasterResponse == MasterACK)
0017AC  78401E     MOV.B [W14], W0
0017AE  E00400     CP0.B W0
0017B0  3A0002     BRA NZ, 0x17B6
154:               		{ I2C_SDA_L; }	// Send Acknowledge
0017B2  A862F4     BSET LATG, #3
0017B4  370001     BRA 0x17B8
155:               	else
156:               		{ I2C_SDA_HF; } // Send NACK
0017B6  A962F4     BCLR LATG, #3
157:               	I2C_SCL_HF;
0017B8  A942F4     BCLR LATG, #2
158:               	Delay_SCL;
0017BA  200200     MOV #0x20, W0
0017BC  200001     MOV #0x0, W1
0017BE  07033B     RCALL ___delay32
159:               	I2C_SCL_L;
0017C0  A842F4     BSET LATG, #2
160:               	I2C_SDA_HF;
0017C2  A962F4     BCLR LATG, #3
161:               	return (TempUChar02);
0017C4  BFC88D     MOV.B TempUChar02, WREG
162:               }
0017C6  FA8000     ULNK
0017C8  060000     RETURN
163:               
164:               #define Si7020_NoDeviceFound	0xFF
165:               #define Si7020_MeasureCmdNACK	0xFE
166:               #define Si7020_CmdNoHoldRH		0xF5
167:               #define Si7020_Good				0x01
168:               //--------------------------------------------------------------
169:               // For Manual: Needs Details
170:               unsigned char Si7020_ReadRH_Start(void)
171:               {
0017CA  FA0000     LNK #0x0
172:               	I2C_StartBit();
0017CC  07FF55     RCALL I2C_StartBit
173:               	I2C_SlaveAddressAnd(SlaveWrite);
0017CE  EB4000     CLR.B W0
0017D0  07FF62     RCALL I2C_SlaveAddressAnd
174:               	if (SlaveReponse() == SlaveNACK)
0017D2  07FF8D     RCALL SlaveReponse
0017D4  504FE1     SUB.B W0, #0x1, [W15]
0017D6  3A0002     BRA NZ, 0x17DC
175:               		return (Si7020_NoDeviceFound);
0017D8  EBC000     SETM.B W0
0017DA  370009     BRA 0x17EE
176:               	I2C_SendByte(Si7020_CmdNoHoldRH);
0017DC  B3CF50     MOV.B #0xF5, W0
0017DE  07FFA2     RCALL I2C_SendByte
177:               	if (SlaveReponse() == SlaveNACK)
0017E0  07FF86     RCALL SlaveReponse
0017E2  504FE1     SUB.B W0, #0x1, [W15]
0017E4  3A0002     BRA NZ, 0x17EA
178:               		return (Si7020_MeasureCmdNACK);
0017E6  B3CFE0     MOV.B #0xFE, W0
0017E8  370002     BRA 0x17EE
179:               	I2C_StartBit(); //Restart
0017EA  07FF46     RCALL I2C_StartBit
180:               	return (Si7020_Good);
0017EC  B3C010     MOV.B #0x1, W0
181:               }
0017EE  FA8000     ULNK
0017F0  060000     RETURN
182:               
183:               #define Si7020_Data_Complete	1
184:               #define Si7020_Data_Not_Ready	0
185:               //--------------------------------------------------------------
186:               // For Manual: Needs Details
187:               unsigned char Si7020_ReadRH_Again(void)
188:               {
0017F2  FA0000     LNK #0x0
189:               	I2C_SlaveAddressAnd(SlaveRead);
0017F4  B3C010     MOV.B #0x1, W0
0017F6  07FF4F     RCALL I2C_SlaveAddressAnd
190:               	if (SlaveReponse() == SlaveNACK)
0017F8  07FF7A     RCALL SlaveReponse
0017FA  504FE1     SUB.B W0, #0x1, [W15]
0017FC  3A0002     BRA NZ, 0x1802
191:               		return (Si7020_Data_Not_Ready);
0017FE  EB4000     CLR.B W0
001800  370009     BRA 0x1814
192:               	I2C_DataByteH = I2C_GetByte(MasterACK);
001802  EB4000     CLR.B W0
001804  07FFAD     RCALL I2C_GetByte
001806  FB8000     ZE W0, W0
001808  884440     MOV W0, I2C_DataByteH
193:               	I2C_DataByteL = I2C_GetByte(MasterNACK);
00180A  B3C010     MOV.B #0x1, W0
00180C  07FFA9     RCALL I2C_GetByte
00180E  FB8000     ZE W0, W0
001810  884450     MOV W0, I2C_DataByteL
194:               	// to do: need to capture checksum; just for customer?
195:               /*	TempUChar01 = I2C_GetByte();*/
196:               	return (Si7020_Data_Complete);
001812  B3C010     MOV.B #0x1, W0
197:               }
001814  FA8000     ULNK
001816  060000     RETURN
198:               
199:               //--------------------------------------------------------------
200:               void Si7020_ReadRH(void)
201:               {
001818  FA0000     LNK #0x0
202:               	if (Si7020_ReadRH_Start() != Si7020_Good){
00181A  07FFD7     RCALL Si7020_ReadRH_Start
00181C  504FE1     SUB.B W0, #0x1, [W15]
00181E  320007     BRA Z, 0x182E
203:                       UART1PutStr("sigood");
001820  287DE0     MOV #0x87DE, W0
001822  070279     RCALL UART1PutStr
204:               		return;
001824  37000A     BRA 0x183A
205:                   }
206:               	while( Si7020_ReadRH_Again() != Si7020_Data_Complete)
00182E  000000     NOP
001830  07FFE0     RCALL Si7020_ReadRH_Again
001832  504FE1     SUB.B W0, #0x1, [W15]
001834  3AFFF8     BRA NZ, 0x1826
207:               	{
208:                       UART1PutStr("while");
001826  287E50     MOV #0x87E5, W0
001828  070276     RCALL UART1PutStr
209:               		ClrWdt();
00182A  FE6000     CLRWDT
00182C  370001     BRA 0x1830
210:               	}
211:               	I2C_StopBit();
001836  07FF11     RCALL I2C_StopBit
212:               	return;
001838  000000     NOP
213:               }
00183A  FA8000     ULNK
00183C  060000     RETURN
00183E  FA0000     LNK #0x0
214:               
215:               ////==============================================================
---  C:/Users/IdeaPad/MPLABXProjects/picTest.X/rtcc.c  --------------------------------------------------
1:                 
2:                 /**
3:                   RTCC Generated Driver API Header File
4:                 
5:                   @Company:
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name:
9:                     rtcc.c
10:                
11:                  @Summary:
12:                    This is the generated header file for the RTCC driver using MPLAB(c) Code Configurator
13:                
14:                  @Description:
15:                    This header file provides APIs for driver for RTCC.
16:                    Generation Information :
17:                        Product Revision  :  MPLAB(c) Code Configurator - v3.00
18:                        Device            :  PIC24FJ128GA306
19:                        Driver Version    :  0.5
20:                    The generated drivers are tested against the following:
21:                        Compiler          :  XC16 1.26
22:                        MPLAB 	          :  MPLAB X 3.20
23:                */
24:                
25:                /*
26:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
27:                
28:                Microchip licenses to you the right to use, modify, copy and distribute
29:                Software only when embedded on a Microchip microcontroller or digital signal
30:                controller that is integrated into your product or third party product
31:                (pursuant to the sublicense terms in the accompanying license agreement).
32:                
33:                You should refer to the license agreement accompanying this Software for
34:                additional information regarding your rights and obligations.
35:                
36:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                 */
47:                
48:                
49:                /**
50:                 Section: Included Files
51:                */
52:                
53:                #include <xc.h>
54:                #include "rtcc.h"
55:                
56:                /**
57:                * Section: Function Prototype
58:                */
59:                static bool rtccTimeInitialized;
60:                static bool RTCCTimeInitialized(void);
61:                static uint8_t ConvertHexToBCD(uint8_t hexvalue);
62:                static uint8_t ConvertBCDToHex(uint8_t bcdvalue);
63:                
64:                /**
65:                * Section: Driver Interface Function Definitions
66:                */
67:                
68:                void RTCC_Initialize(void)
69:                {
001352  FA0000     LNK #0x0
70:                   // Turn on the secondary oscillator
71:                   __builtin_write_OSCCONL(0x02);
001354  200023     MOV #0x2, W3
001356  200461     MOV #0x46, W1
001358  200572     MOV #0x57, W2
00135A  207424     MOV #0x742, W4
00135C  784A01     MOV.B W1, [W4]
00135E  784A02     MOV.B W2, [W4]
001360  784A03     MOV.B W3, [W4]
72:                
73:                   // Set the RTCWREN bit
74:                   __builtin_write_RTCWEN();   
001362  200550     MOV #0x55, W0
001364  883B30     MOV W0, NVMKEY
001366  200AA0     MOV #0xAA, W0
001368  883B30     MOV W0, NVMKEY
00136A  A8A627     BSET 0x627, #5
75:                
76:                   RCFGCALbits.RTCEN = 0;
00136C  A9E627     BCLR 0x627, #7
77:                   
78:                   if(!RTCCTimeInitialized())
00136E  070020     RCALL _RTCCTimeInitialized
001370  A20400     BTG.B W0, #0
001372  E00400     CP0.B W0
001374  32000C     BRA Z, 0x138E
79:                   {
80:                       // set RTCC time 2016-03-02 09-31-47
81:                       RCFGCALbits.RTCPTR = 3;        // start the sequence
001376  803130     MOV RCFGCAL, W0
001378  A08000     BSET W0, #8
00137A  A09000     BSET W0, #9
00137C  883130     MOV W0, RCFGCAL
82:                       RTCVAL = 0x16;    // YEAR
00137E  200160     MOV #0x16, W0
001380  883120     MOV W0, RTCVAL
83:                       RTCVAL = 0x302;    // MONTH-1/DAY-1
001382  203020     MOV #0x302, W0
001384  883120     MOV W0, RTCVAL
84:                       RTCVAL = 0x309;    // WEEKDAY/HOURS
001386  203090     MOV #0x309, W0
001388  883120     MOV W0, RTCVAL
85:                       RTCVAL = 0x3147;    // MINUTES/SECONDS
00138A  231470     MOV #0x3147, W0
00138C  883120     MOV W0, RTCVAL
86:                   }
87:                
88:                   RCFGCALbits.RTCOE = 1; // Enable RTCC output
00138E  A84627     BSET 0x627, #2
89:                   // RTCOUT Alarm Pulse; PWSPRE disabled; RTCLK SOSC; PWCPRE disabled; PWCEN disabled; PWCPOL disabled; 
90:                   RTCPWC = 0x0000;
001390  EF2628     CLR RTCPWC
91:                
92:                           
93:                   // Enable RTCC, clear RTCWREN
94:                   RCFGCALbits.RTCEN = 1;
001392  A8E627     BSET 0x627, #7
95:                   RCFGCALbits.RTCWREN = 0;
001394  A9A627     BCLR 0x627, #5
96:                
97:                }
001396  FA8000     ULNK
001398  060000     RETURN
98:                /**
99:                    void DRV_RTCC_Initialize (void)
100:               */
101:               void DRV_RTCC_Initialize (void)
102:               {
00139A  FA0000     LNK #0x0
103:                   RTCC_Initialize();
00139C  07FFDA     RCALL RTCC_Initialize
104:               }
00139E  FA8000     ULNK
0013A0  060000     RETURN
105:               
106:               /**
107:                This function implements RTCC_TimeReset.This function is used to
108:                used by application to reset the RTCC value and reinitialize RTCC value.
109:               */
110:               void RTCC_TimeReset(bool reset)
111:               {
0013A2  FA0002     LNK #0x2
0013A4  784F00     MOV.B W0, [W14]
112:                   rtccTimeInitialized = reset;
0013A6  78411E     MOV.B [W14], W2
0013A8  2088E1     MOV #0x88E, W1
0013AA  784882     MOV.B W2, [W1]
113:               }
0013AC  FA8000     ULNK
0013AE  060000     RETURN
114:               
115:               static bool RTCCTimeInitialized(void)
116:               {
0013B0  FA0000     LNK #0x0
117:                   return(rtccTimeInitialized);
0013B2  BFC88E     MOV.B rtccTimeInitialized, WREG
118:               }
0013B4  FA8000     ULNK
0013B6  060000     RETURN
0013B8  FA0004     LNK #0x4
0013BA  980710     MOV W0, [W14+2]
119:               
120:               /**
121:                This function implements RTCC_TimeGet. It access the 
122:                registers of  RTCC and writes to them the values provided 
123:                in the function argument currentTime
124:               */
125:               
126:               bool RTCC_TimeGet(struct tm *currentTime)
127:               {
0013B8  FA0004     LNK #0x4
128:                   uint16_t register_value;
129:                   if(RCFGCALbits.RTCSYNC){
0013BC  803132     MOV RCFGCAL, W2
0013BE  210000     MOV #0x1000, W0
0013C0  610000     AND W2, W0, W0
0013C2  E00000     CP0 W0
0013C4  320002     BRA Z, 0x13CA
130:                       return false;
0013C6  EB4000     CLR.B W0
0013C8  37004C     BRA 0x1462
131:                   }
132:               
133:                  // Set the RTCWREN bit
134:                  __builtin_write_RTCWEN();
0013CA  200551     MOV #0x55, W1
0013CC  883B31     MOV W1, NVMKEY
0013CE  200AA1     MOV #0xAA, W1
0013D0  883B31     MOV W1, NVMKEY
0013D2  A8A627     BSET 0x627, #5
135:               
136:                   RCFGCALbits.RTCPTR = 3;
0013D4  803130     MOV RCFGCAL, W0
0013D6  A08000     BSET W0, #8
0013D8  A09000     BSET W0, #9
0013DA  883130     MOV W0, RCFGCAL
137:                   register_value = RTCVAL;
0013DC  803121     MOV RTCVAL, W1
0013DE  780F01     MOV W1, [W14]
138:                   currentTime->tm_year = ConvertBCDToHex(register_value & 0x00FF);
0013E0  78001E     MOV [W14], W0
0013E2  784000     MOV.B W0, W0
0013E4  070113     RCALL _ConvertBCDToHex
0013E6  FB8080     ZE W0, W1
0013E8  90001E     MOV [W14+2], W0
0013EA  980051     MOV W1, [W0+10]
139:                   RCFGCALbits.RTCPTR = 2;
0013EC  803130     MOV RCFGCAL, W0
0013EE  A18000     BCLR W0, #8
0013F0  A09000     BSET W0, #9
0013F2  883130     MOV W0, RCFGCAL
140:                   register_value = RTCVAL;
0013F4  803121     MOV RTCVAL, W1
0013F6  780F01     MOV W1, [W14]
141:                   currentTime->tm_mon = ConvertBCDToHex((register_value & 0xFF00) >> 8);
0013F8  78001E     MOV [W14], W0
0013FA  DE0048     LSR W0, #8, W0
0013FC  784000     MOV.B W0, W0
0013FE  070106     RCALL _ConvertBCDToHex
001400  FB8080     ZE W0, W1
001402  90001E     MOV [W14+2], W0
001404  980041     MOV W1, [W0+8]
142:                   currentTime->tm_mday = ConvertBCDToHex(register_value & 0x00FF);
001406  78001E     MOV [W14], W0
001408  784000     MOV.B W0, W0
00140A  070100     RCALL _ConvertBCDToHex
00140C  FB8080     ZE W0, W1
00140E  90001E     MOV [W14+2], W0
001410  980031     MOV W1, [W0+6]
143:                   RCFGCALbits.RTCPTR = 1;
001412  803130     MOV RCFGCAL, W0
001414  A08000     BSET W0, #8
001416  A19000     BCLR W0, #9
001418  883130     MOV W0, RCFGCAL
144:                   register_value = RTCVAL;
00141A  803121     MOV RTCVAL, W1
00141C  780F01     MOV W1, [W14]
145:                   currentTime->tm_wday = ConvertBCDToHex((register_value & 0xFF00) >> 8);
00141E  78001E     MOV [W14], W0
001420  DE0048     LSR W0, #8, W0
001422  784000     MOV.B W0, W0
001424  0700F3     RCALL _ConvertBCDToHex
001426  FB8080     ZE W0, W1
001428  90001E     MOV [W14+2], W0
00142A  980061     MOV W1, [W0+12]
146:                   currentTime->tm_hour = ConvertBCDToHex(register_value & 0x00FF);
00142C  78001E     MOV [W14], W0
00142E  784000     MOV.B W0, W0
001430  0700ED     RCALL _ConvertBCDToHex
001432  FB8080     ZE W0, W1
001434  90001E     MOV [W14+2], W0
001436  980021     MOV W1, [W0+4]
147:                   RCFGCALbits.RTCPTR = 0;
001438  803130     MOV RCFGCAL, W0
00143A  A18000     BCLR W0, #8
00143C  A19000     BCLR W0, #9
00143E  883130     MOV W0, RCFGCAL
148:                   register_value = RTCVAL;
001440  803121     MOV RTCVAL, W1
001442  780F01     MOV W1, [W14]
149:                   currentTime->tm_min = ConvertBCDToHex((register_value & 0xFF00) >> 8);
001444  78001E     MOV [W14], W0
001446  DE0048     LSR W0, #8, W0
001448  784000     MOV.B W0, W0
00144A  0700E0     RCALL _ConvertBCDToHex
00144C  FB8080     ZE W0, W1
00144E  90001E     MOV [W14+2], W0
001450  980011     MOV W1, [W0+2]
150:                   currentTime->tm_sec = ConvertBCDToHex(register_value & 0x00FF);
001452  78001E     MOV [W14], W0
001454  784000     MOV.B W0, W0
001456  0700DA     RCALL _ConvertBCDToHex
001458  FB8080     ZE W0, W1
00145A  90001E     MOV [W14+2], W0
00145C  780801     MOV W1, [W0]
151:               
152:                   RCFGCALbits.RTCWREN = 0;
00145E  A9A627     BCLR 0x627, #5
153:               
154:                   return true;
001460  B3C010     MOV.B #0x1, W0
155:               }
001462  FA8000     ULNK
001464  060000     RETURN
001466  FA0002     LNK #0x2
001468  780F00     MOV W0, [W14]
156:               /**
157:                   bool DRV_RTCC_TimeGet(struct tm *currentTime)
158:               */
159:               bool DRV_RTCC_TimeGet(struct tm *currentTime)
160:               {
001466  FA0002     LNK #0x2
161:                   return(RTCC_TimeGet(currentTime));
00146A  78001E     MOV [W14], W0
00146C  07FFA5     RCALL RTCC_TimeGet
162:               }
00146E  FA8000     ULNK
001470  060000     RETURN
001472  FA0002     LNK #0x2
001474  781F88     MOV W8, [W15++]
001476  780F00     MOV W0, [W14]
163:               
164:               /**
165:                * This function sets the RTCC value and takes the input time in decimal format
166:               */
167:               
168:               void RTCC_TimeSet(struct tm *initialTime)
169:               {
001472  FA0002     LNK #0x2
170:                  // Set the RTCWREN bit
171:                  __builtin_write_RTCWEN();
001478  200551     MOV #0x55, W1
00147A  883B31     MOV W1, NVMKEY
00147C  200AA1     MOV #0xAA, W1
00147E  883B31     MOV W1, NVMKEY
001480  A8A627     BSET 0x627, #5
172:               
173:                  RCFGCALbits.RTCEN = 0;
001482  A9E627     BCLR 0x627, #7
174:                  
175:               
176:                  // set RTCC initial time
177:                  RCFGCALbits.RTCPTR = 3;                               // start the sequence
001484  803130     MOV RCFGCAL, W0
001486  A08000     BSET W0, #8
001488  A09000     BSET W0, #9
00148A  883130     MOV W0, RCFGCAL
178:                  RTCVAL =  ConvertHexToBCD(initialTime->tm_year);                        // YEAR
00148C  78001E     MOV [W14], W0
00148E  900050     MOV [W0+10], W0
001490  784000     MOV.B W0, W0
001492  0700A4     RCALL _ConvertHexToBCD
001494  FB8000     ZE W0, W0
001496  883120     MOV W0, RTCVAL
179:                  RTCVAL = (ConvertHexToBCD(initialTime->tm_mon) << 8) | ConvertHexToBCD(initialTime->tm_mday);  // MONTH-1/DAY-1
001498  78001E     MOV [W14], W0
00149A  900040     MOV [W0+8], W0
00149C  784000     MOV.B W0, W0
00149E  07009E     RCALL _ConvertHexToBCD
0014A0  FB8000     ZE W0, W0
0014A2  DD0448     SL W0, #8, W8
0014A4  78001E     MOV [W14], W0
0014A6  900030     MOV [W0+6], W0
0014A8  784000     MOV.B W0, W0
0014AA  070098     RCALL _ConvertHexToBCD
0014AC  FB8000     ZE W0, W0
0014AE  700008     IOR W0, W8, W0
0014B0  883120     MOV W0, RTCVAL
180:                  RTCVAL = (ConvertHexToBCD(initialTime->tm_wday) << 8) | ConvertHexToBCD(initialTime->tm_hour); // WEEKDAY/HOURS
0014B2  78001E     MOV [W14], W0
0014B4  900060     MOV [W0+12], W0
0014B6  784000     MOV.B W0, W0
0014B8  070091     RCALL _ConvertHexToBCD
0014BA  FB8000     ZE W0, W0
0014BC  DD0448     SL W0, #8, W8
0014BE  78001E     MOV [W14], W0
0014C0  900020     MOV [W0+4], W0
0014C2  784000     MOV.B W0, W0
0014C4  07008B     RCALL _ConvertHexToBCD
0014C6  FB8000     ZE W0, W0
0014C8  700008     IOR W0, W8, W0
0014CA  883120     MOV W0, RTCVAL
181:                  RTCVAL = (ConvertHexToBCD(initialTime->tm_min) << 8) | ConvertHexToBCD(initialTime->tm_sec);   // MINUTES/SECONDS
0014CC  78001E     MOV [W14], W0
0014CE  900010     MOV [W0+2], W0
0014D0  784000     MOV.B W0, W0
0014D2  070084     RCALL _ConvertHexToBCD
0014D4  FB8000     ZE W0, W0
0014D6  DD0448     SL W0, #8, W8
0014D8  78001E     MOV [W14], W0
0014DA  780010     MOV [W0], W0
0014DC  784000     MOV.B W0, W0
0014DE  07007E     RCALL _ConvertHexToBCD
0014E0  FB8000     ZE W0, W0
0014E2  700008     IOR W0, W8, W0
0014E4  883120     MOV W0, RTCVAL
182:                            
183:                  // Enable RTCC, clear RTCWREN         
184:                  RCFGCALbits.RTCEN = 1;  
0014E6  A8E627     BSET 0x627, #7
185:                  RCFGCALbits.RTCWREN = 0;
0014E8  A9A627     BCLR 0x627, #5
186:                  
187:               
188:               }
0014EA  78044F     MOV [--W15], W8
0014EC  FA8000     ULNK
0014EE  060000     RETURN
189:               
190:               /**
191:                This function reads the RTCC time and returns the date and time in BCD format
192:                 */
193:               bool RTCC_BCDTimeGet(bcdTime_t *currentTime)
194:               {
0014F0  FA0004     LNK #0x4
0014F2  980710     MOV W0, [W14+2]
195:                   uint16_t register_value;
196:                   if(RCFGCALbits.RTCSYNC){
0014F4  803132     MOV RCFGCAL, W2
0014F6  210000     MOV #0x1000, W0
0014F8  610000     AND W2, W0, W0
0014FA  E00000     CP0 W0
0014FC  320002     BRA Z, 0x1502
197:                       return false;
0014FE  EB4000     CLR.B W0
001500  370040     BRA 0x1582
198:                   }
199:               
200:                  // Set the RTCWREN bit
201:                  __builtin_write_RTCWEN();
001502  200551     MOV #0x55, W1
001504  883B31     MOV W1, NVMKEY
001506  200AA1     MOV #0xAA, W1
001508  883B31     MOV W1, NVMKEY
00150A  A8A627     BSET 0x627, #5
202:               
203:                   RCFGCALbits.RTCPTR = 3;
00150C  803130     MOV RCFGCAL, W0
00150E  A08000     BSET W0, #8
001510  A09000     BSET W0, #9
001512  883130     MOV W0, RCFGCAL
204:                   register_value = RTCVAL;
001514  803121     MOV RTCVAL, W1
001516  780F01     MOV W1, [W14]
205:                   currentTime->tm_year = register_value;
001518  78009E     MOV [W14], W1
00151A  90001E     MOV [W14+2], W0
00151C  980051     MOV W1, [W0+10]
206:                   RCFGCALbits.RTCPTR = 2;
00151E  803130     MOV RCFGCAL, W0
001520  A18000     BCLR W0, #8
001522  A09000     BSET W0, #9
001524  883130     MOV W0, RCFGCAL
207:                   register_value = RTCVAL;
001526  803121     MOV RTCVAL, W1
001528  780F01     MOV W1, [W14]
208:                   currentTime->tm_mon = (register_value & 0xFF00) >> 8;
00152A  78001E     MOV [W14], W0
00152C  DE0048     LSR W0, #8, W0
00152E  780080     MOV W0, W1
001530  90001E     MOV [W14+2], W0
001532  980041     MOV W1, [W0+8]
209:                   currentTime->tm_mday = register_value & 0x00FF;
001534  78009E     MOV [W14], W1
001536  200FF0     MOV #0xFF, W0
001538  608080     AND W1, W0, W1
00153A  90001E     MOV [W14+2], W0
00153C  980031     MOV W1, [W0+6]
210:                   RCFGCALbits.RTCPTR = 1;
00153E  803130     MOV RCFGCAL, W0
001540  A08000     BSET W0, #8
001542  A19000     BCLR W0, #9
001544  883130     MOV W0, RCFGCAL
211:                   register_value = RTCVAL;
001546  803121     MOV RTCVAL, W1
001548  780F01     MOV W1, [W14]
212:                   currentTime->tm_wday = (register_value & 0xFF00) >> 8;
00154A  78001E     MOV [W14], W0
00154C  DE0048     LSR W0, #8, W0
00154E  780080     MOV W0, W1
001550  90001E     MOV [W14+2], W0
001552  980061     MOV W1, [W0+12]
213:                   currentTime->tm_hour = register_value & 0x00FF;
001554  78009E     MOV [W14], W1
001556  200FF0     MOV #0xFF, W0
001558  608080     AND W1, W0, W1
00155A  90001E     MOV [W14+2], W0
00155C  980021     MOV W1, [W0+4]
214:                   RCFGCALbits.RTCPTR = 0;
00155E  803130     MOV RCFGCAL, W0
001560  A18000     BCLR W0, #8
001562  A19000     BCLR W0, #9
001564  883130     MOV W0, RCFGCAL
215:                   register_value = RTCVAL;
001566  803121     MOV RTCVAL, W1
001568  780F01     MOV W1, [W14]
216:                   currentTime->tm_min = (register_value & 0xFF00) >> 8;
00156A  78001E     MOV [W14], W0
00156C  DE0048     LSR W0, #8, W0
00156E  780080     MOV W0, W1
001570  90001E     MOV [W14+2], W0
001572  980011     MOV W1, [W0+2]
217:                   currentTime->tm_sec = register_value & 0x00FF;
001574  78009E     MOV [W14], W1
001576  200FF0     MOV #0xFF, W0
001578  608080     AND W1, W0, W1
00157A  90001E     MOV [W14+2], W0
00157C  780801     MOV W1, [W0]
218:                   RCFGCALbits.RTCWREN = 0;
00157E  A9A627     BCLR 0x627, #5
219:               
220:                   return true;
001580  B3C010     MOV.B #0x1, W0
221:               }
001582  FA8000     ULNK
001584  060000     RETURN
001586  FA0002     LNK #0x2
001588  780F00     MOV W0, [W14]
222:               /**
223:                This function takes the input date and time in BCD format and sets the RTCC
224:                */
225:               void RTCC_BCDTimeSet(bcdTime_t *initialTime)
226:               {
001586  FA0002     LNK #0x2
227:                  // Set the RTCWREN bit
228:                  __builtin_write_RTCWEN();
00158A  200551     MOV #0x55, W1
00158C  883B31     MOV W1, NVMKEY
00158E  200AA1     MOV #0xAA, W1
001590  883B31     MOV W1, NVMKEY
001592  A8A627     BSET 0x627, #5
229:               
230:                  RCFGCALbits.RTCEN = 0;
001594  A9E627     BCLR 0x627, #7
231:               
232:                  IFS3bits.RTCIF = false;
001596  A9C08B     BCLR 0x8B, #6
233:                  IEC3bits.RTCIE = 0;
001598  A9C09B     BCLR 0x9B, #6
234:               
235:                  // set RTCC initial time
236:                  RCFGCALbits.RTCPTR = 3;                               // start the sequence
00159A  803130     MOV RCFGCAL, W0
00159C  A08000     BSET W0, #8
00159E  A09000     BSET W0, #9
0015A0  883130     MOV W0, RCFGCAL
237:                  RTCVAL = initialTime->tm_year;                        // YEAR
0015A2  78001E     MOV [W14], W0
0015A4  900050     MOV [W0+10], W0
0015A6  883120     MOV W0, RTCVAL
238:                  RTCVAL = (initialTime->tm_mon << 8) | initialTime->tm_mday;  // MONTH-1/DAY-1
0015A8  78001E     MOV [W14], W0
0015AA  900040     MOV [W0+8], W0
0015AC  DD00C8     SL W0, #8, W1
0015AE  78001E     MOV [W14], W0
0015B0  900030     MOV [W0+6], W0
0015B2  700001     IOR W0, W1, W0
0015B4  883120     MOV W0, RTCVAL
239:                  RTCVAL = (initialTime->tm_wday << 8) | initialTime->tm_hour; // WEEKDAY/HOURS
0015B6  78001E     MOV [W14], W0
0015B8  900060     MOV [W0+12], W0
0015BA  DD00C8     SL W0, #8, W1
0015BC  78001E     MOV [W14], W0
0015BE  900020     MOV [W0+4], W0
0015C0  700001     IOR W0, W1, W0
0015C2  883120     MOV W0, RTCVAL
240:                  RTCVAL = (initialTime->tm_min << 8) | initialTime->tm_sec;   // MINUTES/SECONDS
0015C4  78001E     MOV [W14], W0
0015C6  900010     MOV [W0+2], W0
0015C8  DD00C8     SL W0, #8, W1
0015CA  78001E     MOV [W14], W0
0015CC  780010     MOV [W0], W0
0015CE  700001     IOR W0, W1, W0
0015D0  883120     MOV W0, RTCVAL
241:               
242:                  // Enable RTCC, clear RTCWREN
243:                  RCFGCALbits.RTCEN = 1;
0015D2  A8E627     BSET 0x627, #7
244:                  RCFGCALbits.RTCWREN = 0;
0015D4  A9A627     BCLR 0x627, #5
245:               
246:                  IEC3bits.RTCIE = 1;
0015D6  A8C09B     BSET 0x9B, #6
247:               
248:               }
0015D8  FA8000     ULNK
0015DA  060000     RETURN
249:               
250:               static uint8_t ConvertHexToBCD(uint8_t hexvalue)
251:               {
0015DC  FA0004     LNK #0x4
0015DE  984720     MOV.B W0, [W14+2]
252:                   uint8_t bcdvalue;
253:                   bcdvalue = (hexvalue / 10) << 4;
0015E0  90402E     MOV.B [W14+2], W0
0015E2  FB8080     ZE W0, W1
0015E4  2000A0     MOV #0xA, W0
0015E6  780100     MOV W0, W2
0015E8  090011     REPEAT #0x11
0015EA  D88082     DIV.UW W1, W2
0015EC  784080     MOV.B W0, W1
0015EE  200040     MOV #0x4, W0
0015F0  DD0800     SL W1, W0, W0
0015F2  784F00     MOV.B W0, [W14]
254:                   bcdvalue = bcdvalue | (hexvalue % 10);
0015F4  90402E     MOV.B [W14+2], W0
0015F6  FB8080     ZE W0, W1
0015F8  2000A0     MOV #0xA, W0
0015FA  780100     MOV W0, W2
0015FC  090011     REPEAT #0x11
0015FE  D88082     DIV.UW W1, W2
001600  FD0080     EXCH W0, W1
001602  784000     MOV.B W0, W0
001604  704F1E     IOR.B W0, [W14], [W14]
255:                   return (bcdvalue);
001606  78401E     MOV.B [W14], W0
256:               }
001608  FA8000     ULNK
00160A  060000     RETURN
00160C  FA0004     LNK #0x4
00160E  984720     MOV.B W0, [W14+2]
257:               
258:               static uint8_t ConvertBCDToHex(uint8_t bcdvalue)
259:               {
00160C  FA0004     LNK #0x4
260:                   uint8_t hexvalue;
261:                   hexvalue = (((bcdvalue & 0xF0) >> 4)* 10) + (bcdvalue & 0x0F);
001610  90402E     MOV.B [W14+2], W0
001612  FB8000     ZE W0, W0
001614  DE0044     LSR W0, #4, W0
001616  784000     MOV.B W0, W0
001618  B9006A     MUL.SU W0, #10, W0
00161A  780000     MOV W0, W0
00161C  784080     MOV.B W0, W1
00161E  90402E     MOV.B [W14+2], W0
001620  60406F     AND.B W0, #0xF, W0
001622  40CF00     ADD.B W1, W0, [W14]
262:                   return hexvalue;
001624  78401E     MOV.B [W14], W0
263:               }
001626  FA8000     ULNK
001628  060000     RETURN
264:               
265:               
266:               /* Function:
267:                   bool RTCC_Task(void)
268:               
269:                 Summary:
270:                   Status function which returns the RTCC interrupt flag status
271:               
272:                 Description:
273:                   This is the status function for the RTCC peripheral. 
274:               */
275:               bool RTCC_Task(void)
276:               {
00162A  FA0002     LNK #0x2
277:                   bool status;
278:                   status = IFS3bits.RTCIF;
00162C  800450     MOV IFS3, W0
00162E  DE004E     LSR W0, #14, W0
001630  604061     AND.B W0, #0x1, W0
001632  FB8000     ZE W0, W0
001634  A7F000     BTSC W0, #15
001636  EA0000     NEG W0, W0
001638  EA0000     NEG W0, W0
00163A  DE004F     LSR W0, #15, W0
00163C  784F00     MOV.B W0, [W14]
279:                   if( IFS3bits.RTCIF)
00163E  800451     MOV IFS3, W1
001640  240000     MOV #0x4000, W0
001642  608000     AND W1, W0, W0
001644  E00000     CP0 W0
001646  320001     BRA Z, 0x164A
280:                   {
281:                      IFS3bits.RTCIF = false;
001648  A9C08B     BCLR 0x8B, #6
282:                   }
283:                   return status;
00164A  78401E     MOV.B [W14], W0
284:               }
00164C  FA8000     ULNK
00164E  060000     RETURN
001650  FA0000     LNK #0x0
285:               
286:               
287:               /**
288:                End of File
289:               */
---  C:/Users/IdeaPad/MPLABXProjects/picTest.X/oled_print.c  --------------------------------------------
1:                 #include "oled_print.h"
2:                 #include "oled.h"
3:                 
4:                 
5:                 /* Private variables **********************************************************/
6:                 #define COURSOR_MAX_POS     64U     // 128 cols * 8 lines
7:                 static uint16_t coursor = 0;        // holds coursor position
8:                 
9:                 /* Font ***********************************************************************/
10:                static const uint8_t font[95][5] =
11:                {
12:                    { 0x00, 0x00, 0x00, 0x00, 0x00 }, // ' ' 0x20
13:                    { 0x00, 0x00, 0x4f, 0x00, 0x00 }, // !   0x21
14:                    { 0x00, 0x07, 0x00, 0x07, 0x00 }, // "   0x22
15:                    { 0x14, 0x7f, 0x14, 0x7f, 0x14 }, // #   0x23
16:                    { 0x24, 0x2a, 0x7f, 0x2a, 0x12 }, // $   0x24
17:                    { 0x23, 0x13, 0x08, 0x64, 0x62 }, // %   0x25
18:                    { 0x36, 0x49, 0x55, 0x22, 0x50 }, // &   0x26
19:                    { 0x00, 0x05, 0x03, 0x00, 0x00 }, // '   0x27
20:                    { 0x00, 0x1c, 0x22, 0x41, 0x00 }, // (   0x28
21:                    { 0x00, 0x41, 0x22, 0x1c, 0x00 }, // )   0x29
22:                    { 0x14, 0x08, 0x3e, 0x08, 0x14 }, // *   0x2A
23:                    { 0x08, 0x08, 0x3e, 0x08, 0x08 }, // +   0x2B
24:                    { 0x00, 0x50, 0x30, 0x00, 0x00 }, // ,   0x2C
25:                    { 0x08, 0x08, 0x08, 0x08, 0x08 }, // -   0x2D
26:                    { 0x00, 0x60, 0x60, 0x00, 0x00 }, // .   0x2E
27:                    { 0x20, 0x10, 0x08, 0x04, 0x02 }, // /   0x2F
28:                    { 0x3e, 0x51, 0x49, 0x45, 0x3e }, // 0   0x30
29:                    { 0x00, 0x42, 0x7f, 0x40, 0x00 }, // 1   0x31
30:                    { 0x42, 0x61, 0x51, 0x49, 0x46 }, // 2   0x32
31:                    { 0x21, 0x41, 0x45, 0x4b, 0x31 }, // 3   0x33
32:                    { 0x18, 0x14, 0x12, 0x7f, 0x10 }, // 4   0x34
33:                    { 0x27, 0x45, 0x45, 0x45, 0x39 }, // 5   0x35
34:                    { 0x3c, 0x4a, 0x49, 0x49, 0x30 }, // 6   0x36
35:                    { 0x01, 0x71, 0x09, 0x05, 0x03 }, // 7   0x37
36:                    { 0x36, 0x49, 0x49, 0x49, 0x36 }, // 8   0x38
37:                    { 0x06, 0x49, 0x49, 0x29, 0x1e }, // 9   0x39
38:                    { 0x00, 0x36, 0x36, 0x00, 0x00 }, // :   0x3A
39:                    { 0x00, 0x56, 0x36, 0x00, 0x00 }, // ;   0x3B
40:                    { 0x08, 0x14, 0x22, 0x41, 0x00 }, // <   0x3C
41:                    { 0x14, 0x14, 0x14, 0x14, 0x14 }, // =   0x3D
42:                    { 0x00, 0x41, 0x22, 0x14, 0x08 }, // >   0x3E
43:                    { 0x02, 0x01, 0x51, 0x09, 0x06 }, // ?   0x3F
44:                    { 0x32, 0x49, 0x79, 0x41, 0x3e }, // @   0x40
45:                    { 0x7e, 0x11, 0x11, 0x11, 0x7e }, // A   0x41
46:                    { 0x7f, 0x49, 0x49, 0x49, 0x36 }, // B   0x42
47:                    { 0x3e, 0x41, 0x41, 0x41, 0x22 }, // C   0x43
48:                    { 0x7f, 0x41, 0x41, 0x22, 0x1c }, // D   0x44
49:                    { 0x7f, 0x49, 0x49, 0x49, 0x41 }, // E   0x45
50:                    { 0x7f, 0x09, 0x09, 0x09, 0x01 }, // F   0x46
51:                    { 0x3e, 0x41, 0x49, 0x49, 0x7a }, // G   0x47
52:                    { 0x7f, 0x08, 0x08, 0x08, 0x7f }, // H   0x48
53:                    { 0x00, 0x41, 0x7f, 0x41, 0x00 }, // I   0x49
54:                    { 0x20, 0x40, 0x41, 0x3f, 0x01 }, // J   0x4A
55:                    { 0x7f, 0x08, 0x14, 0x22, 0x41 }, // K   0x4B
56:                    { 0x7f, 0x40, 0x40, 0x40, 0x40 }, // L   0x4C
57:                    { 0x7f, 0x02, 0x0c, 0x02, 0x7f }, // M   0x4D
58:                    { 0x7f, 0x04, 0x08, 0x10, 0x7f }, // N   0x4E
59:                    { 0x3e, 0x41, 0x41, 0x41, 0x3e }, // O   0x4F
60:                    { 0x7f, 0x09, 0x09, 0x09, 0x06 }, // P   0X50
61:                    { 0x3e, 0x41, 0x51, 0x21, 0x5e }, // Q   0X51
62:                    { 0x7f, 0x09, 0x19, 0x29, 0x46 }, // R   0X52
63:                    { 0x46, 0x49, 0x49, 0x49, 0x31 }, // S   0X53
64:                    { 0x01, 0x01, 0x7f, 0x01, 0x01 }, // T   0X54
65:                    { 0x3f, 0x40, 0x40, 0x40, 0x3f }, // U   0X55
66:                    { 0x1f, 0x20, 0x40, 0x20, 0x1f }, // V   0X56
67:                    { 0x3f, 0x40, 0x38, 0x40, 0x3f }, // W   0X57
68:                    { 0x63, 0x14, 0x08, 0x14, 0x63 }, // X   0X58
69:                    { 0x07, 0x08, 0x70, 0x08, 0x07 }, // Y   0X59
70:                    { 0x61, 0x51, 0x49, 0x45, 0x43 }, // Z   0X5A
71:                    { 0x00, 0x7f, 0x41, 0x41, 0x00 }, // [   0X5B
72:                    { 0x02, 0x04, 0x08, 0x10, 0x20 }, // "\" 0X5C
73:                    { 0x00, 0x41, 0x41, 0x7f, 0x00 }, // ]   0X5D
74:                    { 0x04, 0x02, 0x01, 0x02, 0x04 }, // ^   0X5E
75:                    { 0x40, 0x40, 0x40, 0x40, 0x40 }, // _   0X5F
76:                    { 0x00, 0x01, 0x02, 0x04, 0x00 }, // `   0X60
77:                    { 0x20, 0x54, 0x54, 0x54, 0x78 }, // a   0X61
78:                    { 0x7f, 0x48, 0x44, 0x44, 0x38 }, // b   0X62
79:                    { 0x38, 0x44, 0x44, 0x44, 0x20 }, // c   0X63
80:                    { 0x38, 0x44, 0x44, 0x48, 0x7f }, // d   0X64
81:                    { 0x38, 0x54, 0x54, 0x54, 0x18 }, // e   0X65
82:                    { 0x08, 0x7e, 0x09, 0x01, 0x02 }, // f   0X66
83:                    { 0x0c, 0x52, 0x52, 0x52, 0x3e }, // g   0X67
84:                    { 0x7f, 0x08, 0x04, 0x04, 0x78 }, // h   0X68
85:                    { 0x00, 0x44, 0x7d, 0x40, 0x00 }, // i   0X69
86:                    { 0x20, 0x40, 0x44, 0x3d, 0x00 }, // j   0X6A
87:                    { 0x7f, 0x10, 0x28, 0x44, 0x00 }, // k   0X6B
88:                    { 0x00, 0x41, 0x7f, 0x40, 0x00 }, // l   0X6C
89:                    { 0x7c, 0x04, 0x18, 0x04, 0x78 }, // m   0X6D
90:                    { 0x7c, 0x08, 0x04, 0x04, 0x78 }, // n   0X6E
91:                    { 0x38, 0x44, 0x44, 0x44, 0x38 }, // o   0X6F
92:                    { 0x7c, 0x14, 0x14, 0x14, 0x08 }, // p   0X70
93:                    { 0x08, 0x14, 0x14, 0x18, 0x7c }, // q   0X71
94:                    { 0x7c, 0x08, 0x04, 0x04, 0x08 }, // r   0X72
95:                    { 0x48, 0x54, 0x54, 0x54, 0x20 }, // s   0X73
96:                    { 0x04, 0x3f, 0x44, 0x40, 0x20 }, // t   0X74
97:                    { 0x3c, 0x40, 0x40, 0x20, 0x7c }, // u   0X75
98:                    { 0x1c, 0x20, 0x40, 0x20, 0x1c }, // v   0X76
99:                    { 0x3c, 0x40, 0x30, 0x40, 0x3c }, // w   0X77
100:                   { 0x44, 0x28, 0x10, 0x28, 0x44 }, // x   0X78
101:                   { 0x0c, 0x50, 0x50, 0x50, 0x3c }, // y   0X79
102:                   { 0x44, 0x64, 0x54, 0x4c, 0x44 }, // z   0X7A
103:                   { 0x00, 0x08, 0x36, 0x41, 0x00 }, // {   0X7B
104:                   { 0x00, 0x00, 0x7f, 0x00, 0x00 }, // |   0X7C
105:                   { 0x00, 0x41, 0x36, 0x08, 0x00 }, // }   0X7D
106:                   { 0x02, 0x01, 0x02, 0x04, 0x02 }, // ~   0X7E
107:               };
108:               
109:               
110:               /* Private funtions ************************************************************/
111:               static inline uint8_t isPrintable(const uint8_t c);
112:               static void writeChar(uint8_t* buffer, uint8_t c, const uint8_t col, const uint8_t line);
113:               
114:               
115:               /* Publi print functions **********************************************************/
116:               void oled_putc(uint8_t* buffer, char c, uint8_t col, uint8_t line)
117:               {
001984  FA0006     LNK #0x6
001986  780F00     MOV W0, [W14]
001988  984721     MOV.B W1, [W14+2]
00198A  984732     MOV.B W2, [W14+3]
00198C  984743     MOV.B W3, [W14+4]
118:                   // Check for vertical space
119:                   if (col > (OLED_WIDTH - CHAR_WIDTH))
00198E  9040BE     MOV.B [W14+3], W1
001990  B3C7A0     MOV.B #0x7A, W0
001992  50CF80     SUB.B W1, W0, [W15]
001994  3E0023     BRA GTU, 0x19DC
120:                       return;
0019DC  000000     NOP
121:               
122:                   //
123:                   if (isPrintable(c))
001996  90402E     MOV.B [W14+2], W0
001998  070041     RCALL _isPrintable
00199A  E00400     CP0.B W0
00199C  32000E     BRA Z, 0x19BA
124:                   {
125:                       coursor += CHAR_WIDTH;
00199E  804140     MOV coursor, W0
0019A0  400066     ADD W0, #0x6, W0
0019A2  884140     MOV W0, coursor
126:                       coursor &= COURSOR_MAX_POS;
0019A4  804141     MOV coursor, W1
0019A6  200400     MOV #0x40, W0
0019A8  608000     AND W1, W0, W0
0019AA  884140     MOV W0, coursor
127:                       writeChar(buffer, c, col, line);
0019AC  90402E     MOV.B [W14+2], W0
0019AE  9041CE     MOV.B [W14+4], W3
0019B0  90413E     MOV.B [W14+3], W2
0019B2  784080     MOV.B W0, W1
0019B4  78001E     MOV [W14], W0
0019B6  070041     RCALL _writeChar
0019B8  370012     BRA 0x19DE
128:                   }
129:                   else if ( c == '\n')
0019BA  90402E     MOV.B [W14+2], W0
0019BC  504FEA     SUB.B W0, #0xA, [W15]
0019BE  32000F     BRA Z, 0x19DE
130:                   {
131:               
132:                   }
133:                   else if ( c == '\t')
0019C0  90402E     MOV.B [W14+2], W0
0019C2  504FE9     SUB.B W0, #0x9, [W15]
0019C4  3A000C     BRA NZ, 0x19DE
134:                   {
135:                       oled_putc(buffer, ' ', col, line);
0019C6  9041CE     MOV.B [W14+4], W3
0019C8  90413E     MOV.B [W14+3], W2
0019CA  B3C201     MOV.B #0x20, W1
0019CC  78001E     MOV [W14], W0
0019CE  07FFDA     RCALL oled_putc
136:                       oled_putc(buffer, ' ', col, line);
0019D0  9041CE     MOV.B [W14+4], W3
0019D2  90413E     MOV.B [W14+3], W2
0019D4  B3C201     MOV.B #0x20, W1
0019D6  78001E     MOV [W14], W0
0019D8  07FFD5     RCALL oled_putc
0019DA  370001     BRA 0x19DE
137:                   }
138:               }
0019DE  FA8000     ULNK
0019E0  060000     RETURN
0019E2  FA000A     LNK #0xA
0019E4  980710     MOV W0, [W14+2]
0019E6  980721     MOV W1, [W14+4]
0019E8  984762     MOV.B W2, [W14+6]
0019EA  984773     MOV.B W3, [W14+7]
0019EC  984F04     MOV.B W4, [W14+8]
0019EE  EB4000     CLR.B W0
0019F0  784F00     MOV.B W0, [W14]
0019F2  37000E     BRA 0x1A10
0019F4  90002E     MOV [W14+4], W0
0019F6  784010     MOV.B [W0], W0
0019F8  9041FE     MOV.B [W14+7], W3
0019FA  90416E     MOV.B [W14+6], W2
0019FC  784080     MOV.B W0, W1
0019FE  90001E     MOV [W14+2], W0
001A00  07FFC1     RCALL oled_putc
001A02  90001E     MOV [W14+2], W0
001A04  400066     ADD W0, #0x6, W0
001A06  980710     MOV W0, [W14+2]
001A08  E84F1E     INC.B [W14], [W14]
001A0A  90002E     MOV [W14+4], W0
001A0C  E80000     INC W0, W0
001A0E  980720     MOV W0, [W14+4]
001A10  90480E     MOV.B [W14+8], W0
001A12  78409E     MOV.B [W14], W1
001A14  50CF80     SUB.B W1, W0, [W15]
001A16  39FFEE     BRA NC, 0x19F4
001A18  FA8000     ULNK
001A1A  060000     RETURN
001A1C  FA0002     LNK #0x2
001A1E  784F00     MOV.B W0, [W14]
001A20  78401E     MOV.B [W14], W0
001A22  504FFF     SUB.B W0, #0x1F, [W15]
001A24  360006     BRA LEU, 0x1A32
001A26  B3C7E0     MOV.B #0x7E, W0
001A28  78409E     MOV.B [W14], W1
001A2A  50CF80     SUB.B W1, W0, [W15]
001A2C  3E0002     BRA GTU, 0x1A32
001A2E  200010     MOV #0x1, W0
001A30  370001     BRA 0x1A34
001A32  EB0000     CLR W0
001A34  784000     MOV.B W0, W0
001A36  FA8000     ULNK
001A38  060000     RETURN
001A3A  FA000A     LNK #0xA
001A3C  980720     MOV W0, [W14+4]
001A3E  984761     MOV.B W1, [W14+6]
001A40  984772     MOV.B W2, [W14+7]
001A42  984F03     MOV.B W3, [W14+8]
001A44  90407E     MOV.B [W14+7], W0
001A46  FB8080     ZE W0, W1
001A48  90480E     MOV.B [W14+8], W0
001A4A  FB8000     ZE W0, W0
001A4C  DD0047     SL W0, #7, W0
001A4E  408000     ADD W1, W0, W0
001A50  9000AE     MOV [W14+4], W1
001A52  408F00     ADD W1, W0, [W14]
001A54  9040EE     MOV.B [W14+6], W1
001A56  B3CE00     MOV.B #0xE0, W0
001A58  40C000     ADD.B W1, W0, W0
001A5A  984760     MOV.B W0, [W14+6]
001A5C  EB4000     CLR.B W0
001A5E  984720     MOV.B W0, [W14+2]
001A60  37000F     BRA 0x1A80
001A62  90406E     MOV.B [W14+6], W0
001A64  FB8000     ZE W0, W0
001A66  9040AE     MOV.B [W14+2], W1
001A68  FB8101     ZE W1, W2
001A6A  B90065     MUL.SU W0, #5, W0
001A6C  780000     MOV W0, W0
001A6E  400002     ADD W0, W2, W0
001A70  285D61     MOV #0x85D6, W1
001A72  7840E1     MOV.B [W1+W0], W1
001A74  78001E     MOV [W14], W0
001A76  784801     MOV.B W1, [W0]
001A78  90402E     MOV.B [W14+2], W0
001A7A  E84000     INC.B W0, W0
001A7C  984720     MOV.B W0, [W14+2]
001A7E  E80F1E     INC [W14], [W14]
001A80  90402E     MOV.B [W14+2], W0
001A82  504FE5     SUB.B W0, #0x5, [W15]
001A84  36FFEE     BRA LEU, 0x1A62
001A86  FA8000     ULNK
001A88  060000     RETURN
139:               
140:               void oled_puts(uint8_t* buffer, const char* s, uint8_t col, uint8_t line, uint8_t sLen)
141:               {
0019E2  FA000A     LNK #0xA
142:                   uint8_t i = 0;
0019EE  EB4000     CLR.B W0
0019F0  784F00     MOV.B W0, [W14]
143:                   for(; i < sLen; ++i, ++s)
0019F2  37000E     BRA 0x1A10
001A08  E84F1E     INC.B [W14], [W14]
001A0A  90002E     MOV [W14+4], W0
001A0C  E80000     INC W0, W0
001A0E  980720     MOV W0, [W14+4]
001A10  90480E     MOV.B [W14+8], W0
001A12  78409E     MOV.B [W14], W1
001A14  50CF80     SUB.B W1, W0, [W15]
001A16  39FFEE     BRA NC, 0x19F4
144:                   {
145:                       oled_putc(buffer, *s, col, line);
0019F4  90002E     MOV [W14+4], W0
0019F6  784010     MOV.B [W0], W0
0019F8  9041FE     MOV.B [W14+7], W3
0019FA  90416E     MOV.B [W14+6], W2
0019FC  784080     MOV.B W0, W1
0019FE  90001E     MOV [W14+2], W0
001A00  07FFC1     RCALL oled_putc
146:                       buffer += CHAR_WIDTH;
001A02  90001E     MOV [W14+2], W0
001A04  400066     ADD W0, #0x6, W0
001A06  980710     MOV W0, [W14+2]
147:                   }
148:               }
001A18  FA8000     ULNK
001A1A  060000     RETURN
001A1C  FA0002     LNK #0x2
001A1E  784F00     MOV.B W0, [W14]
149:               
150:               
151:               /* staic functions (helpers) **************************************************/
152:               static inline uint8_t isPrintable(const uint8_t c)
153:               {
001A1C  FA0002     LNK #0x2
154:                   return( (0x20 <= c) && (c <= 0x7E));
001A20  78401E     MOV.B [W14], W0
001A22  504FFF     SUB.B W0, #0x1F, [W15]
001A24  360006     BRA LEU, 0x1A32
001A26  B3C7E0     MOV.B #0x7E, W0
001A28  78409E     MOV.B [W14], W1
001A2A  50CF80     SUB.B W1, W0, [W15]
001A2C  3E0002     BRA GTU, 0x1A32
001A2E  200010     MOV #0x1, W0
001A30  370001     BRA 0x1A34
001A32  EB0000     CLR W0
001A34  784000     MOV.B W0, W0
155:               }
001A36  FA8000     ULNK
001A38  060000     RETURN
156:               
157:               void writeChar(uint8_t* buffer, uint8_t c, const uint8_t x, const uint8_t line)
158:               {
001A3A  FA000A     LNK #0xA
001A3C  980720     MOV W0, [W14+4]
001A3E  984761     MOV.B W1, [W14+6]
001A40  984772     MOV.B W2, [W14+7]
001A42  984F03     MOV.B W3, [W14+8]
159:                   // Point to correct buffer address
160:                   uint8_t *p = &buffer[x + (line * OLED_WIDTH)];
001A44  90407E     MOV.B [W14+7], W0
001A46  FB8080     ZE W0, W1
001A48  90480E     MOV.B [W14+8], W0
001A4A  FB8000     ZE W0, W0
001A4C  DD0047     SL W0, #7, W0
001A4E  408000     ADD W1, W0, W0
001A50  9000AE     MOV [W14+4], W1
001A52  408F00     ADD W1, W0, [W14]
161:               
162:                   // Offset character 0x20 times
163:                   c -= ' ';
001A54  9040EE     MOV.B [W14+6], W1
001A56  B3CE00     MOV.B #0xE0, W0
001A58  40C000     ADD.B W1, W0, W0
001A5A  984760     MOV.B W0, [W14+6]
164:               
165:                   // Move character to buffer
166:                   uint8_t i = 0;
001A5C  EB4000     CLR.B W0
001A5E  984720     MOV.B W0, [W14+2]
167:                   for (; i < CHAR_WIDTH; ++i, ++p)
001A60  37000F     BRA 0x1A80
001A78  90402E     MOV.B [W14+2], W0
001A7A  E84000     INC.B W0, W0
001A7C  984720     MOV.B W0, [W14+2]
001A7E  E80F1E     INC [W14], [W14]
001A80  90402E     MOV.B [W14+2], W0
001A82  504FE5     SUB.B W0, #0x5, [W15]
001A84  36FFEE     BRA LEU, 0x1A62
168:                   {
169:                       *p = font[c][i];
001A62  90406E     MOV.B [W14+6], W0
001A64  FB8000     ZE W0, W0
001A66  9040AE     MOV.B [W14+2], W1
001A68  FB8101     ZE W1, W2
001A6A  B90065     MUL.SU W0, #5, W0
001A6C  780000     MOV W0, W0
001A6E  400002     ADD W0, W2, W0
001A70  285D61     MOV #0x85D6, W1
001A72  7840E1     MOV.B [W1+W0], W1
001A74  78001E     MOV [W14], W0
001A76  784801     MOV.B W1, [W0]
170:                   }
171:               }
001A86  FA8000     ULNK
001A88  060000     RETURN
001A8A  FA0002     LNK #0x2
---  C:/Users/IdeaPad/MPLABXProjects/picTest.X/oled_draw.c  ---------------------------------------------
1:                 #include "oled_draw.h"
2:                 #include "oled.h"
3:                 
4:                 void oled_putPixel(uint8_t* buffer, uint8_t x, uint8_t y)
5:                 {
001DB0  FA0004     LNK #0x4
001DB2  780F00     MOV W0, [W14]
001DB4  984721     MOV.B W1, [W14+2]
001DB6  984732     MOV.B W2, [W14+3]
6:                 //    buffer[x + ((y / 8) * OLED_WIDTH)] = (1 << (y % 8));
7:                     buffer[x + ((y >> 3) * OLED_WIDTH)] |= (1 << (y & 7));
001DB8  90402E     MOV.B [W14+2], W0
001DBA  FB8080     ZE W0, W1
001DBC  90403E     MOV.B [W14+3], W0
001DBE  FB8000     ZE W0, W0
001DC0  DE0043     LSR W0, #3, W0
001DC2  784000     MOV.B W0, W0
001DC4  FB8000     ZE W0, W0
001DC6  DD0047     SL W0, #7, W0
001DC8  408000     ADD W1, W0, W0
001DCA  40001E     ADD W0, [W14], W0
001DCC  9040AE     MOV.B [W14+2], W1
001DCE  FB8101     ZE W1, W2
001DD0  9040BE     MOV.B [W14+3], W1
001DD2  FB8081     ZE W1, W1
001DD4  DE08C3     LSR W1, #3, W1
001DD6  784081     MOV.B W1, W1
001DD8  FB8081     ZE W1, W1
001DDA  DD08C7     SL W1, #7, W1
001DDC  410081     ADD W2, W1, W1
001DDE  40809E     ADD W1, [W14], W1
001DE0  784091     MOV.B [W1], W1
001DE2  784101     MOV.B W1, W2
001DE4  9040BE     MOV.B [W14+3], W1
001DE6  FB8081     ZE W1, W1
001DE8  6080E7     AND W1, #0x7, W1
001DEA  200013     MOV #0x1, W3
001DEC  DD1881     SL W3, W1, W1
001DEE  784081     MOV.B W1, W1
001DF0  714081     IOR.B W2, W1, W1
001DF2  784801     MOV.B W1, [W0]
8:                 }
001DF4  FA8000     ULNK
001DF6  060000     RETURN
001DF8  000CA8     NOP
---  C:/Users/IdeaPad/MPLABXProjects/picTest.X/oled.c  --------------------------------------------------
1:                 #include "oled.h"           // main functions
2:                 #include "oled_print.h"     // print functions
3:                 #include "oled_draw.h"      // draw functions
4:                 #include "SSD1306.h"        // hardware driver functions
5:                 //#include "device/pinconfig.h"
6:                 //#include "common/globals.h" // __delay_ms() needs FCY defined
7:                 #define FCY     16000000ULL
8:                 #include <libpic30.h>       // __delay_ms()
9:                 #include <string.h>         // memset()
10:                #include <stdio.h>          // vsnprintf()
11:                #include "extralDefines.h"
12:                
13:                
14:                
15:                
16:                
17:                
18:                #if !defined(OLED_CS) || !defined (OLED_RST) || !defined(OLED_DC) || \
19:                    !defined(OLED_CS_TRS) || !defined (OLED_RST_TRS) || !defined(OLED_DC_TRS)
20:                #error("Must define OLED_CS, OLED_RST and OLED_DC ")
21:                #endif
22:                
23:                
24:                /* Private variables **********************************************************/
25:                static uint8_t displayBuffer[OLED_BUFFSIZE] = {0};
26:                
27:                
28:                /* Private functions **********************************************************/
29:                static void oled_config(void);
30:                
31:                /* Main functions *************************************************************/
32:                void oled_config(void)
33:                {
00183E  FA0000     LNK #0x0
34:                    OLED_CS_TRS = 0;     // CS as output
001840  A9E2C9     BCLR 0x2C9, #7
35:                    OLED_RST_TRS = 0;    // RST as output
001842  A9C2C8     BCLR TRISB, #6
36:                    OLED_DC_TRS = 0;     // CD as output
001844  A9C2C9     BCLR 0x2C9, #6
37:                
38:                    // Configure SPI1
39:                    ssd1306_init();
001846  07FD76     RCALL ssd1306_init
40:                }
001848  FA8000     ULNK
00184A  060000     RETURN
41:                
42:                void oled_init(void)
43:                {
00184C  FA0000     LNK #0x0
44:                    oled_config();      // hardware config
00184E  07FFF7     RCALL _oled_config
45:                    oled_reset();       // display config
001850  070002     RCALL oled_reset
46:                }
001852  FA8000     ULNK
001854  060000     RETURN
47:                
48:                void oled_reset(void)
49:                {
001856  FA0000     LNK #0x0
50:                    // Reset
51:                    OLED_RST = 1;
001858  A8C2CC     BSET LATB, #6
52:                    __delay_ms(1);
00185A  23E800     MOV #0x3E80, W0
00185C  200001     MOV #0x0, W1
00185E  0702EB     RCALL ___delay32
53:                    OLED_RST = 0;
001860  A9C2CC     BCLR LATB, #6
54:                    __delay_ms(10);
001862  271000     MOV #0x7100, W0
001864  200021     MOV #0x2, W1
001866  0702E7     RCALL ___delay32
55:                    OLED_RST = 1;
001868  A8C2CC     BSET LATB, #6
56:                
57:                    // Init sequence for 128x64 OLED module taken from
58:                    // page 64 of SSD1306 datasheet
59:                    ssd1306cmd_displayOnOff(DISPLAY_OFF);               // 0xAE
00186A  EB4000     CLR.B W0
00186C  07FC3C     RCALL ssd1306cmd_displayOnOff
60:                    ssd1306cmd_displayMultiplexRatio(0x3F);             // 0xA8, 0x3F
00186E  B3C3F0     MOV.B #0x3F, W0
001870  07FCF9     RCALL ssd1306cmd_displayMultiplexRatio
61:                    ssd1306cmd_displayOffset(0);                        // 0xD3, 0x00
001872  EB4000     CLR.B W0
001874  07FD0E     RCALL ssd1306cmd_displayOffset
62:                    ssd1306cmd_displayStartLine(0);                     // 0x40, 0x00
001876  EB4000     CLR.B W0
001878  07FCDF     RCALL ssd1306cmd_displayStartLine
63:                    ssd1306cmd_displaySegmentRemap(ADDR_127);           // 0xA1
00187A  B3C010     MOV.B #0x1, W0
00187C  07FCE8     RCALL ssd1306cmd_displaySegmentRemap
64:                    ssd1306cmd_displayComDirection(COM_REMAPPED);       // 0xC8
00187E  B3C080     MOV.B #0x8, W0
001880  07FCFD     RCALL ssd1306cmd_displayComDirection
65:                    ssd1306cmd_displayComPins(COM_SEQUENTIAL_ENABLE_COM_REMAP);  // 0xDA, 0x02
001882  B3C120     MOV.B #0x12, W0
001884  07FD12     RCALL ssd1306cmd_displayComPins
66:                    ssd1306cmd_contrast(0x7F);                          // 0x81, 0x7F
001886  B3C7F0     MOV.B #0x7F, W0
001888  07FC0D     RCALL ssd1306cmd_contrast
67:                    ssd1306cmd_entireDisplayOn(RESUME_TO_RAM);          // 0xA4
00188A  EB4000     CLR.B W0
00188C  07FC16     RCALL ssd1306cmd_entireDisplayOn
68:                    ssd1306cmd_displayNormalInverse(DISPLAY_NORMAL);    // 0xA6
00188E  EB4000     CLR.B W0
001890  07FC1F     RCALL ssd1306cmd_displayNormalInverse
69:                    ssd1306cmd_setClock(0x08, 0x00);                    // 0xD5, 0x80
001892  EB4080     CLR.B W1
001894  B3C080     MOV.B #0x8, W0
001896  07FD14     RCALL ssd1306cmd_setClock
70:                    ssd1306cmd_chargePump(CHARGE_ENABLE);               // 0x8D, 0x14
001898  B3C140     MOV.B #0x14, W0
00189A  07FD41     RCALL ssd1306cmd_chargePump
71:                    ssd1306cmd_addrMemoryAddressingMode(MODE_HORIZONTAL);    // 0x20, 0x00
00189C  EB4000     CLR.B W0
00189E  07FC94     RCALL ssd1306cmd_addrMemoryAddressingMode
72:                    ssd1306cmd_displayOnOff(DISPLAY_ON);                // 0xAF
0018A0  B3C010     MOV.B #0x1, W0
0018A2  07FC21     RCALL ssd1306cmd_displayOnOff
73:                }
0018A4  FA8000     ULNK
0018A6  060000     RETURN
74:                
75:                void oled_render(void)
76:                {
0018A8  FA0000     LNK #0x0
77:                    ssd1306cmd_addrColumnAddress(0, OLED_LAST_COL);
0018AA  B3C7F1     MOV.B #0x7F, W1
0018AC  EB4000     CLR.B W0
0018AE  07FC98     RCALL ssd1306cmd_addrColumnAddress
78:                    ssd1306cmd_addrPageAddress(0, OLED_LAST_PAGE);
0018B0  B3C071     MOV.B #0x7, W1
0018B2  EB4000     CLR.B W0
0018B4  07FCA6     RCALL ssd1306cmd_addrPageAddress
79:                    ssd1306_send(displayBuffer, OLED_BUFFSIZE);
0018B6  204001     MOV #0x400, W1
0018B8  208900     MOV #0x890, W0
0018BA  07FBDC     RCALL ssd1306_send
80:                }
0018BC  FA8000     ULNK
0018BE  060000     RETURN
81:                
82:                void oled_clearDisplay(void)
83:                {
0018C0  FA0000     LNK #0x0
84:                    memset(displayBuffer, 0, OLED_BUFFSIZE);
0018C2  204002     MOV #0x400, W2
0018C4  EB0080     CLR W1
0018C6  208900     MOV #0x890, W0
0018C8  07F679     RCALL _memset
85:                }
0018CA  FA8000     ULNK
0018CC  060000     RETURN
0018CE  FA0004     LNK #0x4
0018D0  784F00     MOV.B W0, [W14]
0018D2  984711     MOV.B W1, [W14+1]
0018D4  984722     MOV.B W2, [W14+2]
86:                
87:                /* Print functions ************************************************************/
88:                void oled_printc(uint8_t col, uint8_t line, char c)
89:                {
0018CE  FA0004     LNK #0x4
90:                    // Check for a valid line [1 to 8]
91:                    if (line < 0 || line > OLED_NPAGES)
0018D6  90401E     MOV.B [W14+1], W0
0018D8  504FE8     SUB.B W0, #0x8, [W15]
0018DA  3E000A     BRA GTU, 0x18F0
92:                        return;
0018F0  000000     NOP
93:                
94:                    // to ease further computations, send values with 0 index
95:                    oled_putc(displayBuffer, c, --col, --line);
0018DC  90401E     MOV.B [W14+1], W0
0018DE  E94000     DEC.B W0, W0
0018E0  984710     MOV.B W0, [W14+1]
0018E2  E94F1E     DEC.B [W14], [W14]
0018E4  90419E     MOV.B [W14+1], W3
0018E6  78411E     MOV.B [W14], W2
0018E8  9040AE     MOV.B [W14+2], W1
0018EA  208900     MOV #0x890, W0
0018EC  07004B     RCALL oled_putc
0018EE  370001     BRA 0x18F2
96:                }
0018F2  FA8000     ULNK
0018F4  060000     RETURN
0018F6  FA0006     LNK #0x6
0018F8  984720     MOV.B W0, [W14+2]
0018FA  984731     MOV.B W1, [W14+3]
0018FC  980722     MOV W2, [W14+4]
97:                
98:                void oled_prints(uint8_t col, uint8_t line, const char* s)
99:                {
0018F6  FA0006     LNK #0x6
100:                   uint8_t sLen = strlen(s);
0018FE  90002E     MOV [W14+4], W0
001900  07F664     RCALL _strlen
001902  784F00     MOV.B W0, [W14]
101:                   if((sLen + CHAR_WIDTH) + col > OLED_WIDTH)
001904  FB809E     ZE [W14], W1
001906  90402E     MOV.B [W14+2], W0
001908  FB8000     ZE W0, W0
00190A  408000     ADD W1, W0, W0
00190C  4000E6     ADD W0, #0x6, W1
00190E  200800     MOV #0x80, W0
001910  508F80     SUB W1, W0, [W15]
001912  3E000D     BRA GTU, 0x192E
102:                       return;
00192E  000000     NOP
103:               
104:                   oled_puts(displayBuffer, s, --col, --line, sLen);
001914  90403E     MOV.B [W14+3], W0
001916  E94000     DEC.B W0, W0
001918  984730     MOV.B W0, [W14+3]
00191A  90402E     MOV.B [W14+2], W0
00191C  E94000     DEC.B W0, W0
00191E  984720     MOV.B W0, [W14+2]
001920  78421E     MOV.B [W14], W4
001922  9041BE     MOV.B [W14+3], W3
001924  90412E     MOV.B [W14+2], W2
001926  9000AE     MOV [W14+4], W1
001928  208900     MOV #0x890, W0
00192A  07005B     RCALL oled_puts
00192C  370001     BRA 0x1930
105:               }
001930  FA8000     ULNK
001932  060000     RETURN
106:               
107:               void oled_printf(uint8_t col, uint8_t line, const char* format, ...)
108:               {
001934  FA0002     LNK #0x2
001936  784F00     MOV.B W0, [W14]
001938  984711     MOV.B W1, [W14+1]
109:                  // char printBuffer[OLED_WIDTH] = {0};
110:                  // uint8_t maxCharCount = ((OLED_WIDTH / CHAR_WIDTH) - (CHAR_WIDTH * (col-1))) + 1;
111:               
112:                  // va_list  args;     
113:                   //va_start();
114:                   //va_start(args, format);
115:                  // vsprintf(printBuffer, maxCharCount, format, args);    /* TODO: write custom vsprintf() */
116:               
117:                  // uint8_t sLen = strlen(printBuffer);
118:                   //oled_puts(displayBuffer, printBuffer, --col, --line, sLen);
119:                  // va_end(args);
120:               }
00193A  FA8000     ULNK
00193C  060000     RETURN
00193E  FA0002     LNK #0x2
001940  784F00     MOV.B W0, [W14]
001942  984711     MOV.B W1, [W14+1]
121:               
122:               
123:               
124:               /* Draw functions *************************************************************/
125:               void oled_drawPixel(uint8_t x, uint8_t y)
126:               {
00193E  FA0002     LNK #0x2
127:                   // Check for a valid position
128:                   // x: [1 to 128]
129:                   // y: [1 to 64]
130:                   if(x < 1 || x > OLED_WIDTH || y < 1 || y > OLED_HEIGHT)
001944  78401E     MOV.B [W14], W0
001946  E00400     CP0.B W0
001948  320014     BRA Z, 0x1972
00194A  B3C800     MOV.B #0x80, W0
00194C  78409E     MOV.B [W14], W1
00194E  50CF80     SUB.B W1, W0, [W15]
001950  3E0012     BRA GTU, 0x1976
001952  90401E     MOV.B [W14+1], W0
001954  E00400     CP0.B W0
001956  320011     BRA Z, 0x197A
001958  90409E     MOV.B [W14+1], W1
00195A  B3C400     MOV.B #0x40, W0
00195C  50CF80     SUB.B W1, W0, [W15]
00195E  3E000F     BRA GTU, 0x197E
131:                       return;
001972  000000     NOP
001974  370005     BRA 0x1980
001976  000000     NOP
001978  370003     BRA 0x1980
00197A  000000     NOP
00197C  370001     BRA 0x1980
00197E  000000     NOP
132:               
133:                   // put pixel on buffer
134:                   // to ease further computations, send values with 0 index
135:                   oled_putPixel(displayBuffer, --x, --y);
001960  90401E     MOV.B [W14+1], W0
001962  E94000     DEC.B W0, W0
001964  984710     MOV.B W0, [W14+1]
001966  E94F1E     DEC.B [W14], [W14]
001968  90411E     MOV.B [W14+1], W2
00196A  78409E     MOV.B [W14], W1
00196C  208900     MOV #0x890, W0
00196E  070220     RCALL oled_putPixel
001970  370007     BRA 0x1980
136:               }
001980  FA8000     ULNK
001982  060000     RETURN
001984  FA0006     LNK #0x6
---  C:/Users/IdeaPad/MPLABXProjects/picTest.X/mcc_generated_files/interrupt_manager.c  -----------------
1:                 /**
2:                   System Interrupts Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     interrupt_manager.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for setting up the
12:                    interrupts using MPLAB(c) Code Configurator
13:                
14:                  @Description:
15:                    This source file provides implementations for MPLAB(c) Code Configurator interrupts.
16:                    Generation Information : 
17:                        Product Revision  :  MPLAB(c) Code Configurator - v3.00
18:                        Device            :  PIC24FJ128GA306
19:                        Version           :  1.01
20:                    The generated drivers are tested against the following:
21:                        Compiler          :  XC16 1.26
22:                        MPLAB             :  MPLAB X 3.20
23:                */
24:                /*
25:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
26:                
27:                Microchip licenses to you the right to use, modify, copy and distribute
28:                Software only when embedded on a Microchip microcontroller or digital signal
29:                controller that is integrated into your product or third party product
30:                (pursuant to the sublicense terms in the accompanying license agreement).
31:                
32:                You should refer to the license agreement accompanying this Software for
33:                additional information regarding your rights and obligations.
34:                
35:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                 */
46:                
47:                /**
48:                    Section: Includes
49:                */
50:                #include <xc.h>
51:                
52:                /**
53:                    void INTERRUPT_Initialize (void)
54:                */
55:                void INTERRUPT_Initialize (void)
56:                {
001E52  FA0000     LNK #0x0
57:                    //    MICI: MI2C1 - I2C1 Master Events
58:                    //    Priority: 1
59:                        IPC4bits.MI2C1P = 1;
001E54  800560     MOV IPC4, W0
001E56  A04000     BSET W0, #4
001E58  A15000     BCLR W0, #5
001E5A  A16000     BCLR W0, #6
001E5C  880560     MOV W0, IPC4
60:                    //    SICI: SI2C1 - I2C1 Slave Events
61:                    //    Priority: 1
62:                        IPC4bits.SI2C1P = 1;
001E5E  800560     MOV IPC4, W0
001E60  A00000     BSET W0, #0
001E62  A11000     BCLR W0, #1
001E64  A12000     BCLR W0, #2
001E66  880560     MOV W0, IPC4
63:                
64:                }
001E68  FA8000     ULNK
001E6A  060000     RETURN
001E6C  FFFFFF     NOPR
---  C:/Users/IdeaPad/MPLABXProjects/picTest.X/mainPIC.c  -----------------------------------------------
1:                 /*
2:                  * File:   mainPIC.c
3:                  * Author: IdeaPad
4:                  *
5:                  * Created on 24. februar 2016, 11:05
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "oled.h"
11:                #include <stdint.h>
12:                #include "hwConfig.h"
13:                #include "uart1.h"
14:                #include "extralDefines.h"
15:                #include "rtcc.h"
16:                #include <stdlib.h>
17:                
18:                #include "i2c1.h"
19:                
20:                
21:                #define FCY     16000000ULL //TO DO
22:                
23:                #include <libpic30.h>
24:                #include "dht.h"
25:                #include "si7020.h"
26:                
27:                 volatile char cc,cc2,cc3;
28:                volatile uint16_v temperature;
29:                volatile int l;
30:                
31:                /// CONFIGURRATION BITS 
32:                _CONFIG1(JTAGEN_OFF & GCP_OFF & GWRP_OFF & LPCFG_ON & ICS_PGx3 & WINDIS_OFF & FWDTEN_WDT_DIS & FWPSA_PR32 & WDTPS_PS1)
33:                _CONFIG2(IESO_OFF & ALTVREF_ALT_AV_ALT_CV & FNOSC_FRCPLL & FCKSM_CSDCMD & OSCIOFCN_ON & IOL1WAY_OFF & POSCMD_NONE)
34:                _CONFIG3(WPEND_WPENDMEM & WPCFG_WPCFGEN & WPDIS_WPEN & BOREN_OFF & WDTWIN_PS50_0 & SOSCSEL_ON & VBTBOR_OFF & WPFP_WPFP82)
35:                _CONFIG4(DSSWEN_OFF & DSWDTEN_OFF & DSBOREN_OFF & DSWDTOSC_SOSC & DSWDTPS_DSWDTPS0)
36:                
37:                
38:                
39:                struct tm currentTime;
40:                
41:                //Repeater main function
42:                
43:                void RepeaterProcessEvents() {
001A8A  FA0002     LNK #0x2
44:                    unsigned char data = 0;
001A8C  EB4000     CLR.B W0
001A8E  784F00     MOV.B W0, [W14]
45:                
46:                    //wait for data to be received
47:                    data = UART1GetChar();
001A90  070154     RCALL UART1GetChar
001A92  784F00     MOV.B W0, [W14]
48:                
49:                    //send data back on UART TX line
50:                    UART1PutChar(data);
001A94  78401E     MOV.B [W14], W0
001A96  070133     RCALL UART1PutChar
51:                }
001A98  FA8000     ULNK
001A9A  060000     RETURN
52:                
53:                void tester(){
001A9C  FA0000     LNK #0x0
54:                    i2c_start();  
001A9E  07F998     RCALL i2c_start
55:                    send_i2c_byte(0x80);// address +0 write
001AA0  200800     MOV #0x80, W0
001AA2  07FA20     RCALL send_i2c_byte
56:                    
57:                    send_i2c_byte(0xE3);  //0xE3 =0b11100011
001AA4  200E30     MOV #0xE3, W0
001AA6  07FA1E     RCALL send_i2c_byte
58:                    
59:                   i2c_repeatedStart();
001AA8  07F9CE     RCALL i2c_repeatedStart
60:                   //i2c_start(); 
61:                   
62:                   send_i2c_byte(0x81); //adresss +1 read
001AAA  200810     MOV #0x81, W0
001AAC  07FA1B     RCALL send_i2c_byte
63:                   i2c_mIdleI2C1();
001AAE  07FA82     RCALL i2c_mIdleI2C1
64:                    
65:                   cc=i2c_read_ack();
001AB0  07FA62     RCALL i2c_read_ack
001AB2  B7E876     MOV.B WREG, cc
66:                   i2c_ack();
001AB4  07FA89     RCALL i2c_ack
67:                   
68:                  i2c_mIdleI2C1();
001AB6  07FA7E     RCALL i2c_mIdleI2C1
69:                   i2c_ack();
001AB8  07FA87     RCALL i2c_ack
70:                   cc2=i2c_read_ack();
001ABA  07FA5D     RCALL i2c_read_ack
001ABC  B7E877     MOV.B WREG, cc2
71:                   i2c_mIdleI2C1();     /////////////////////// maybe?
001ABE  07FA7A     RCALL i2c_mIdleI2C1
72:                   i2c_nack();
001AC0  07FA94     RCALL i2c_nack
73:                   i2c_stop();
001AC2  07F9A2     RCALL i2c_stop
74:                
75:                   //i2c_ack();
76:                   //i2c_mIdleI2C1();
77:                   
78:                   
79:                   //cc2=i2c_read_ack();
80:                   //cc3=i2c_read();
81:                   
82:                   //i2c_stop();
83:                    
84:                    
85:                    //cc=i2c_read_ack();
86:                   // cc2=i2c_read_ack();
87:                    
88:                    //reset_i2c_bus();
89:                   // i2c_restart();
90:                }
001AC4  FA8000     ULNK
001AC6  060000     RETURN
91:                
92:                void firmwareTest(){
001AC8  FA0000     LNK #0x0
93:                     i2c_start();  
001ACA  07F982     RCALL i2c_start
94:                    send_i2c_byte(0x80);// address +0 write
001ACC  200800     MOV #0x80, W0
001ACE  07FA0A     RCALL send_i2c_byte
95:                    
96:                     send_i2c_byte(0x84);    /// FIRMWARE!!!!!!!!!
001AD0  200840     MOV #0x84, W0
001AD2  07FA08     RCALL send_i2c_byte
97:                    
98:                    send_i2c_byte(0xB8); /// FIRMWARE!!!!!!!!!
001AD4  200B80     MOV #0xB8, W0
001AD6  07FA06     RCALL send_i2c_byte
99:                //0x84 =0b10000100
100:               //0xB8 =0b10111000
101:                   i2c_start(); /// FIRMWARE!!!!!!!!!
001AD8  07F97B     RCALL i2c_start
102:                  send_i2c_byte(0x81); /// FIRMWARE!!!!!!!!!
001ADA  200810     MOV #0x81, W0
001ADC  07FA03     RCALL send_i2c_byte
103:                  
104:                  cc3=i2c_read();
001ADE  07FA34     RCALL i2c_read
001AE0  B7E878     MOV.B WREG, cc3
105:                  
106:                 // i2c_stop();
107:               }
001AE2  FA8000     ULNK
001AE4  060000     RETURN
108:               
109:               //RTCTime time; // declare the type of the time object
110:               
111:               int main(void) {
001AE6  FA0000     LNK #0x0
112:               
113:               
114:                   OSCCON = 0x1102; // clock setup   0001 0001 0000 0010
001AE8  211020     MOV #0x1102, W0
001AEA  883A10     MOV W0, OSCCON
115:                   CLKDIV = 0x0000;
001AEC  EF2744     CLR CLKDIV
116:                   OSCTUN = 0x0000;
001AEE  EF2748     CLR OSCTUN
117:                   RCON |= 0x1100;
001AF0  803A01     MOV RCON, W1
001AF2  211000     MOV #0x1100, W0
001AF4  700001     IOR W0, W1, W0
001AF6  883A00     MOV W0, RCON
118:               
119:               
120:                   /// Hardware setup
121:                   hwInit();
001AF8  070037     RCALL hwInit
122:                   RTCC_Initialize();
001AFA  07FC2B     RCALL RTCC_Initialize
123:                   I2C1_Initialize();
001AFC  07F677     RCALL I2C1_Initialize
124:                   INITIALIZE_SI7020();
001AFE  07FDA8     RCALL INITIALIZE_SI7020
125:               
126:               
127:                   //    MICI: MI2C1 - I2C1 Master Events
128:                   //    Priority: 1
129:                   IPC4bits.MI2C1P = 1;
001B00  800560     MOV IPC4, W0
001B02  A04000     BSET W0, #4
001B04  A15000     BCLR W0, #5
001B06  A16000     BCLR W0, #6
001B08  880560     MOV W0, IPC4
130:                   //    SICI: SI2C1 - I2C1 Slave Events
131:                   //    Priority: 1
132:                   IPC4bits.SI2C1P = 1;
001B0A  800560     MOV IPC4, W0
001B0C  A00000     BSET W0, #0
001B0E  A11000     BCLR W0, #1
001B10  A12000     BCLR W0, #2
001B12  880560     MOV W0, IPC4
133:               
134:                   // Display setup and test
135:                   oled_init();
001B14  07FE9B     RCALL oled_init
136:                   oled_clearDisplay();
001B16  07FED4     RCALL oled_clearDisplay
137:                   oled_prints(1, 6, "Temp:"); // print on center of the screen
001B18  287B22     MOV #0x87B2, W2
001B1A  B3C061     MOV.B #0x6, W1
001B1C  B3C010     MOV.B #0x1, W0
001B1E  07FEEB     RCALL oled_prints
138:                   oled_prints(1, 8, "Humidity:");
001B20  287B82     MOV #0x87B8, W2
001B22  B3C081     MOV.B #0x8, W1
001B24  B3C010     MOV.B #0x1, W0
001B26  07FEE7     RCALL oled_prints
139:                   oled_render();
001B28  07FEBF     RCALL oled_render
140:               
141:               
142:               
143:                   __delay_ms(1000);
001B2A  224000     MOV #0x2400, W0
001B2C  200F41     MOV #0xF4, W1
001B2E  070183     RCALL ___delay32
144:               
145:                   UART1Init(51);
001B30  200330     MOV #0x33, W0
001B32  0700D9     RCALL UART1Init
146:               
147:                   UART1PutChar('b');
001B34  B3C620     MOV.B #0x62, W0
001B36  0700E3     RCALL UART1PutChar
148:               
149:                   UART1PutStr("Init complete");
001B38  287C20     MOV #0x87C2, W0
001B3A  0700ED     RCALL UART1PutStr
150:               
151:               
152:                   while (1) {
153:                   
154:               
155:               
156:                       
157:                       
158:                       //  RTCC_TimeGet(&currentTime);
159:                       UART1PutChar('/');
001B3C  B3C2F0     MOV.B #0x2F, W0
001B3E  0700DF     RCALL UART1PutChar
160:               
161:                       tester();
001B40  07FFAD     RCALL tester
162:                       //i2c_start();
163:                       
164:                      // i2c_ack();
165:                      // firmwareTest();
166:                  temperature.b[0]=cc;
001B42  BFC876     MOV.B cc, WREG
001B44  B7E87A     MOV.B WREG, temperature
167:                  temperature.b[1]=cc2;
001B46  BFC877     MOV.B cc2, WREG
001B48  B7E87B     MOV.B WREG, 0x87B
168:                  
169:                   l=calcuateTemperature(temperature);          
001B4A  8043D0     MOV temperature, W0
001B4C  07FA66     RCALL calcuateTemperature
001B4E  8843E0     MOV W0, l
170:                // may be worth adding a CR or CR/LF
171:                 
172:                            //int16_t test;
173:                   UART1PutChar('*');
001B50  B3C2A0     MOV.B #0x2A, W0
001B52  0700D5     RCALL UART1PutChar
174:                  // UART1PutStr(buf);
175:                   
176:                 //UART1PutChar(l & 0xff);
177:                 //UART1PutChar(l >> 8);
178:                   
179:                 UART1PutChar('*');
001B54  B3C2A0     MOV.B #0x2A, W0
001B56  0700D3     RCALL UART1PutChar
180:                 
181:                        UART1PutChar(cc);
001B58  BFC876     MOV.B cc, WREG
001B5A  0700D1     RCALL UART1PutChar
182:                        UART1PutChar(cc2);  
001B5C  BFC877     MOV.B cc2, WREG
001B5E  0700CF     RCALL UART1PutChar
183:                        //UART1PutStr(l);
184:                        
185:                       // UART1PutChar(calcuateTemperature(cc,cc2));
186:                       __delay_ms(100);
001B60  26A000     MOV #0x6A00, W0
001B62  200181     MOV #0x18, W1
001B64  070168     RCALL ___delay32
187:                  // oled_prints(16, 6, l);
188:                //   oled_render();
189:                  
190:                   }
001B66  37FFEA     BRA 0x1B3C
001B68  FA0000     LNK #0x0
191:                   return (0);
192:               }
193:               
194:               // 15 NA 14-12 Fast RC Oscillator (FRC) 000 // 11 NA 10-8 000 Fast RC Oscillator (FRC) // bit7 0 CLLOCK // Bit 6 NA // bit 5=0 LOCK //bit 4 NA// bit 3 CLOCK fail // bit2 NA // bit 1 Secondary osc  0 // bit 0 OSWEN 
195:               //Loop forever
196:               
197:               
198:               
---  C:/Users/IdeaPad/MPLABXProjects/picTest.X/i2c1.c  --------------------------------------------------
1:                 /**
2:                   I2C1 Generated Driver File
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     i2c1.c
9:                 
10:                  @Summary
11:                    This is the generated header file for the I2C1 driver using MPLAB(c) Code Configurator
12:                
13:                  @Description
14:                    This header file provides APIs for driver for I2C1.
15:                    Generation Information :
16:                        Product Revision  :  MPLAB(c) Code Configurator - v3.00
17:                        Device            :  PIC24FJ128GA306
18:                        Driver Version    :  1.0
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 1.26
21:                        MPLAB 	          :  MPLAB X 3.20
22:                 */
23:                
24:                /*
25:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
26:                
27:                Microchip licenses to you the right to use, modify, copy and distribute
28:                Software only when embedded on a Microchip microcontroller or digital signal
29:                controller that is integrated into your product or third party product
30:                (pursuant to the sublicense terms in the accompanying license agreement).
31:                
32:                You should refer to the license agreement accompanying this Software for
33:                additional information regarding your rights and obligations.
34:                
35:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                 */
46:                
47:                #include "i2c1.h"
48:                #include "si7020.h"
49:                #include "uart1.h"
50:                #include "extralDefines.h"
51:                #define FCY     16000000ULL //TO DO
52:                
53:                #include <libpic30.h>
54:                /**
55:                 Section: Data Types
56:                 */
57:                
58:                /**
59:                  I2C Driver Queue Status Type
60:                
61:                  @Summary
62:                    Defines the type used for the transaction queue status.
63:                
64:                  @Description
65:                    This defines type used to keep track of the queue status.
66:                 */
67:                volatile uint16_t tempo;
68:                typedef union {
69:                
70:                    struct {
71:                        uint8_t full : 1;
72:                        uint8_t empty : 1;
73:                        uint8_t reserved : 6;
74:                    } s;
75:                    uint8_t status;
76:                } I2C_TR_QUEUE_STATUS;
77:                
78:                /**
79:                  I2C Driver Queue Entry Type
80:                
81:                  @Summary
82:                    Defines the object used for an entry in the i2c queue items.
83:                
84:                  @Description
85:                    This defines the object in the i2c queue. Each entry is a composed
86:                    of a list of TRBs, the number of the TRBs and the status of the
87:                    currently processed TRB.
88:                 */
89:                typedef struct {
90:                    uint8_t count; // a count of trb's in the trb list
91:                    I2C1_TRANSACTION_REQUEST_BLOCK *ptrb_list; // pointer to the trb list
92:                    I2C1_MESSAGE_STATUS *pTrFlag; // set with the error of the last trb sent.
93:                    // if all trb's are sent successfully,
94:                    // then this is I2C1_MESSAGE_COMPLETE
95:                } I2C_TR_QUEUE_ENTRY;
96:                
97:                /**
98:                  I2C Master Driver Object Type
99:                
100:                 @Summary
101:                   Defines the object that manages the i2c master.
102:               
103:                 @Description
104:                   This defines the object that manages the sending and receiving of
105:                   i2c master transactions.
106:                */
107:               
108:               typedef struct {
109:                   /* Read/Write Queue */
110:                   I2C_TR_QUEUE_ENTRY *pTrTail; // tail of the queue
111:                   I2C_TR_QUEUE_ENTRY *pTrHead; // head of the queue
112:                   I2C_TR_QUEUE_STATUS trStatus; // status of the last transaction
113:                   uint8_t i2cDoneFlag; // flag to indicate the current
114:                   // transaction is done
115:                   uint8_t i2cErrors; // keeps track of errors
116:               
117:               
118:               } I2C_OBJECT;
119:               
120:               /**
121:                 I2C Master Driver State Enumeration
122:               
123:                 @Summary
124:                   Defines the different states of the i2c master.
125:               
126:                 @Description
127:                   This defines the different states that the i2c master
128:                   used to process transactions on the i2c bus.
129:                */
130:               
131:               typedef enum {
132:                   S_MASTER_IDLE,
133:                   S_MASTER_RESTART,
134:                   S_MASTER_SEND_ADDR,
135:                   S_MASTER_SEND_DATA,
136:                   S_MASTER_SEND_STOP,
137:                   S_MASTER_ACK_ADDR,
138:                   S_MASTER_RCV_DATA,
139:                   S_MASTER_RCV_STOP,
140:                   S_MASTER_ACK_RCV_DATA,
141:                   S_MASTER_NOACK_STOP,
142:                   S_MASTER_SEND_ADDR_10BIT_LSB,
143:                   S_MASTER_10BIT_RESTART,
144:               
145:               } I2C_MASTER_STATES;
146:               
147:               /**
148:                Section: Macro Definitions
149:                */
150:               
151:               /* defined for I2C1 */
152:               
153:               
154:               #ifndef I2C1_CONFIG_TR_QUEUE_LENGTH
155:               #define I2C1_CONFIG_TR_QUEUE_LENGTH 1
156:               #endif
157:               
158:               #define I2C1_TRANSMIT_REG                       I2C1TRN                 // Defines the transmit register used to send data.
159:               #define I2C1_RECEIVE_REG                        I2C1RCV                 // Defines the receive register used to receive data.
160:               
161:               // The following control bits are used in the I2C state machine to manage
162:               // the I2C module and determine next states.
163:               #define I2C1_WRITE_COLLISION_STATUS_BIT         I2C1STATbits.IWCOL      // Defines the write collision status bit.
164:               #define I2C1_ACKNOWLEDGE_STATUS_BIT             I2C1STATbits.ACKSTAT    // I2C ACK status bit.
165:               
166:               #define I2C1_START_CONDITION_ENABLE_BIT         I2C1CONbits.SEN         // I2C START control bit.
167:               #define I2C1_REPEAT_START_CONDITION_ENABLE_BIT  I2C1CONbits.RSEN        // I2C Repeated START control bit.
168:               #define I2C1_RECEIVE_ENABLE_BIT                 I2C1CONbits.RCEN        // I2C Receive enable control bit.
169:               #define I2C1_STOP_CONDITION_ENABLE_BIT          I2C1CONbits.PEN         // I2C STOP control bit.
170:               #define I2C1_ACKNOWLEDGE_ENABLE_BIT             I2C1CONbits.ACKEN       // I2C ACK start control bit.
171:               #define I2C1_ACKNOWLEDGE_DATA_BIT               I2C1CONbits.ACKDT       // I2C ACK data control bit.
172:               
173:               /**
174:                Section: Local Functions
175:                */
176:               
177:               static void I2C1_FunctionComplete(void);
178:               static void I2C1_Stop(I2C1_MESSAGE_STATUS completion_code);
179:               
180:               /**
181:                Section: Local Variables
182:                */
183:               
184:               static I2C_TR_QUEUE_ENTRY i2c1_tr_queue[I2C1_CONFIG_TR_QUEUE_LENGTH];
185:               static I2C_OBJECT i2c1_object;
186:               static I2C_MASTER_STATES i2c1_state = S_MASTER_IDLE;
187:               static uint8_t i2c1_trb_count;
188:               
189:               static I2C1_TRANSACTION_REQUEST_BLOCK *p_i2c1_trb_current;
190:               static I2C_TR_QUEUE_ENTRY *p_i2c1_current = NULL;
191:               
192:               /**
193:                 Section: Driver Interface
194:                */
195:               
196:               void I2C1_Initialize(void) {
0007EC  FA0000     LNK #0x0
197:               
198:                   i2c1_object.pTrHead = i2c1_tr_queue;
0007EE  208520     MOV #0x852, W0
0007F0  20C901     MOV #0xC90, W1
0007F2  980011     MOV W1, [W0+2]
199:                   i2c1_object.pTrTail = i2c1_tr_queue;
0007F4  208520     MOV #0x852, W0
0007F6  20C901     MOV #0xC90, W1
0007F8  780801     MOV W1, [W0]
200:                   i2c1_object.trStatus.s.empty = true;
0007FA  208521     MOV #0x852, W1
0007FC  900021     MOV [W1+4], W0
0007FE  A01000     BSET W0, #1
000800  9800A0     MOV W0, [W1+4]
201:                   i2c1_object.trStatus.s.full = false;
000802  208521     MOV #0x852, W1
000804  900021     MOV [W1+4], W0
000806  A10000     BCLR W0, #0
000808  9800A0     MOV W0, [W1+4]
202:               
203:                   i2c1_object.i2cErrors = 0;
00080A  208520     MOV #0x852, W0
00080C  EB4080     CLR.B W1
00080E  984061     MOV.B W1, [W0+6]
204:               
205:                   // initialize the hardware
206:                   // Baud Rate Generator Value: I2CBRG 2;   
207:                   // Calculated Frequency: 100/404.0 kHz
208:                   I2C1BRG = 0x9D;//9D;  -100 //0x25;-404
000810  2009D0     MOV #0x9D, W0
000812  881020     MOV W0, I2C1BRG
209:                   // ACKEN disabled; STREN disabled; GCEN disabled; SMEN disabled; DISSLW disabled; I2CSIDL disabled; ACKDT Sends ACK; SCLREL Holds; RSEN disabled; IPMIEN disabled; A10M 7 Bit; PEN disabled; RCEN disabled; SEN disabled; I2CEN enabled; 
210:                   I2C1CON = 0x8200;
000814  282000     MOV #0x8200, W0
000816  881030     MOV W0, I2C1CON
211:                   // P disabled; S disabled; BCL disabled; I2COV disabled; IWCOL disabled; 
212:                   I2C1STAT = 0x0000;
000818  EF2208     CLR I2C1STAT
213:               
214:                   /* MI2C1 - I2C1 Master Events */
215:                   // clear the master interrupt flag
216:                   IFS1bits.MI2C1IF = 0;
00081A  A92086     BCLR IFS1, #1
217:                   // enable the master interrupt
218:                   IEC1bits.MI2C1IE = 1;
00081C  A82096     BSET IEC1, #1
219:               
220:               }
00081E  FA8000     ULNK
000820  060000     RETURN
221:               
222:               void DRV_I2C1_Initialize(void) {
000822  FA0000     LNK #0x0
223:                   I2C1_Initialize();
000824  07FFE3     RCALL I2C1_Initialize
224:               }
000826  FA8000     ULNK
000828  060000     RETURN
225:               
226:               uint8_t I2C1_ErrorCountGet(void) {
00082A  FA0002     LNK #0x2
227:                   uint8_t ret;
228:               
229:                   ret = i2c1_object.i2cErrors;
00082C  208520     MOV #0x852, W0
00082E  9040E0     MOV.B [W0+6], W1
000830  784F01     MOV.B W1, [W14]
230:                   return ret;
000832  78401E     MOV.B [W14], W0
231:               }
000834  FA8000     ULNK
000836  060000     RETURN
232:               
233:               void __attribute__((interrupt, no_auto_psv)) _MI2C1Interrupt(void) {
000838  F80036     PUSH RCOUNT
00083A  BE9F80     MOV.D W0, [W15++]
00083C  BE9F82     MOV.D W2, [W15++]
00083E  BE9F84     MOV.D W4, [W15++]
000840  BE9F86     MOV.D W6, [W15++]
000842  FA0000     LNK #0x0
234:               
235:               
236:               
237:                   static uint8_t *pi2c_buf_ptr;
238:                   static uint16_t i2c_address;
239:                   static uint8_t i2c_bytes_left;
240:                   static uint8_t i2c_10bit_address_restart = 0;
241:               
242:               
243:               
244:                   IFS1bits.MI2C1IF = 0;
000844  A92086     BCLR IFS1, #1
245:               
246:                   // Check first if there was a collision.
247:                   // If we have a Write Collision, reset and go to idle state */
248:                   if (I2C1_WRITE_COLLISION_STATUS_BIT) {
000846  801041     MOV I2C1STAT, W1
000848  200800     MOV #0x80, W0
00084A  608000     AND W1, W0, W0
00084C  E00000     CP0 W0
00084E  320008     BRA Z, 0x860
249:                       // clear the Write colision
250:                       I2C1_WRITE_COLLISION_STATUS_BIT = 0;
000850  A9E208     BCLR I2C1STAT, #7
251:                       i2c1_state = S_MASTER_IDLE;
000852  EF285A     CLR i2c1_state
252:                       *(p_i2c1_current->pTrFlag) = I2C1_MESSAGE_FAIL;
000854  804300     MOV p_i2c1_current, W0
000856  900020     MOV [W0+4], W0
000858  EB0080     CLR W1
00085A  780801     MOV W1, [W0]
253:               
254:                       // reset the buffer pointer
255:                       p_i2c1_current = NULL;
00085C  EF2860     CLR p_i2c1_current
256:               
257:                       return;
00085E  37010D     BRA 0xA7A
258:                   }
259:               
260:                   /* Handle the correct i2c state */
261:                   switch (i2c1_state) {
000860  8042D0     MOV i2c1_state, W0
000862  EB0080     CLR W1
000864  2000B2     MOV #0xB, W2
000866  200003     MOV #0x0, W3
000868  500F82     SUB W0, W2, [W15]
00086A  588F83     SUBB W1, W3, [W15]
00086C  3E00FC     BRA GTU, 0xA66
00086E  016000     BRA W0
000870  37000B     BRA 0x888
000872  370039     BRA 0x8E6
000874  370075     BRA 0x960
000876  37009C     BRA 0x9B0
000878  3700F3     BRA 0xA60
00087A  3700C8     BRA 0xA0C
00087C  3700D9     BRA 0xA30
00087E  3700F0     BRA 0xA60
000880  3700DB     BRA 0xA38
000882  3700F1     BRA 0xA66
000884  370034     BRA 0x8EE
000886  370050     BRA 0x928
262:                       case S_MASTER_IDLE: /* In reset state, waiting for data to send */
263:               
264:                           if (i2c1_object.trStatus.s.empty != true) {
000888  208520     MOV #0x852, W0
00088A  900020     MOV [W0+4], W0
00088C  600062     AND W0, #0x2, W0
00088E  E00000     CP0 W0
000890  3A00F3     BRA NZ, 0xA78
265:                               // grab the item pointed by the head
266:                               p_i2c1_current = i2c1_object.pTrHead;
000892  208520     MOV #0x852, W0
000894  900010     MOV [W0+2], W0
000896  884300     MOV W0, p_i2c1_current
267:                               i2c1_trb_count = i2c1_object.pTrHead->count;
000898  208520     MOV #0x852, W0
00089A  900010     MOV [W0+2], W0
00089C  784010     MOV.B [W0], W0
00089E  B7E85C     MOV.B WREG, i2c1_trb_count
268:                               p_i2c1_trb_current = i2c1_object.pTrHead->ptrb_list;
0008A0  208520     MOV #0x852, W0
0008A2  900010     MOV [W0+2], W0
0008A4  900010     MOV [W0+2], W0
0008A6  8842F0     MOV W0, p_i2c1_trb_current
269:               
270:                               i2c1_object.pTrHead++;
0008A8  208520     MOV #0x852, W0
0008AA  900010     MOV [W0+2], W0
0008AC  4000E6     ADD W0, #0x6, W1
0008AE  208520     MOV #0x852, W0
0008B0  980011     MOV W1, [W0+2]
271:               
272:                               // check if the end of the array is reached
273:                               if (i2c1_object.pTrHead == (i2c1_tr_queue + I2C1_CONFIG_TR_QUEUE_LENGTH)) {
0008B2  208520     MOV #0x852, W0
0008B4  900090     MOV [W0+2], W1
0008B6  20C960     MOV #0xC96, W0
0008B8  508F80     SUB W1, W0, [W15]
0008BA  3A0003     BRA NZ, 0x8C2
274:                                   // adjust to restart at the beginning of the array
275:                                   i2c1_object.pTrHead = i2c1_tr_queue;
0008BC  208520     MOV #0x852, W0
0008BE  20C901     MOV #0xC90, W1
0008C0  980011     MOV W1, [W0+2]
276:                               }
277:               
278:                               // since we moved one item to be processed, we know
279:                               // it is not full, so set the full status to false
280:                               i2c1_object.trStatus.s.full = false;
0008C2  208521     MOV #0x852, W1
0008C4  900021     MOV [W1+4], W0
0008C6  A10000     BCLR W0, #0
0008C8  9800A0     MOV W0, [W1+4]
281:               
282:                               // check if the queue is empty
283:                               if (i2c1_object.pTrHead == i2c1_object.pTrTail) {
0008CA  208520     MOV #0x852, W0
0008CC  900090     MOV [W0+2], W1
0008CE  208520     MOV #0x852, W0
0008D0  780010     MOV [W0], W0
0008D2  508F80     SUB W1, W0, [W15]
0008D4  3A0004     BRA NZ, 0x8DE
284:                                   // it is empty so set the empty status to true
285:                                   i2c1_object.trStatus.s.empty = true;
0008D6  208521     MOV #0x852, W1
0008D8  900021     MOV [W1+4], W0
0008DA  A01000     BSET W0, #1
0008DC  9800A0     MOV W0, [W1+4]
286:                               }
287:               
288:                               // send the start condition
289:                               I2C1_START_CONDITION_ENABLE_BIT = 1;
0008DE  A80206     BSET I2C1CON, #0
290:               
291:                               // start the i2c request
292:                               i2c1_state = S_MASTER_SEND_ADDR;
0008E0  200020     MOV #0x2, W0
0008E2  8842D0     MOV W0, i2c1_state
293:                           }
294:               
295:                           break;
0008E4  3700CA     BRA 0xA7A
000A78  000000     NOP
296:               
297:                       case S_MASTER_RESTART:
298:               
299:                           /* check for pending i2c Request */
300:               
301:                           // ... trigger a REPEATED START
302:                           I2C1_REPEAT_START_CONDITION_ENABLE_BIT = 1;
0008E6  A82206     BSET I2C1CON, #1
303:               
304:                           // start the i2c request
305:                           i2c1_state = S_MASTER_SEND_ADDR;
0008E8  200020     MOV #0x2, W0
0008EA  8842D0     MOV W0, i2c1_state
306:               
307:                           break;
0008EC  3700C6     BRA 0xA7A
308:               
309:                       case S_MASTER_SEND_ADDR_10BIT_LSB:
310:               
311:                           if (I2C1_ACKNOWLEDGE_STATUS_BIT) {
0008EE  801041     MOV I2C1STAT, W1
0008F0  280000     MOV #0x8000, W0
0008F2  608000     AND W1, W0, W0
0008F4  E00000     CP0 W0
0008F6  320008     BRA Z, 0x908
312:                               i2c1_object.i2cErrors++;
0008F8  208520     MOV #0x852, W0
0008FA  904060     MOV.B [W0+6], W0
0008FC  E84080     INC.B W0, W1
0008FE  208520     MOV #0x852, W0
000900  984061     MOV.B W1, [W0+6]
313:                               I2C1_Stop(I2C1_MESSAGE_ADDRESS_NO_ACK);
000902  200040     MOV #0x4, W0
000904  0700D2     RCALL _I2C1_Stop
314:                           } else {
315:                               // Remove bit 0 as R/W is never sent here
316:                               I2C1_TRANSMIT_REG = (i2c_address >> 1) & 0x00FF;
000908  804310     MOV i2c_address, W0
00090A  D10080     LSR W0, W1
00090C  200FF0     MOV #0xFF, W0
00090E  608000     AND W1, W0, W0
000910  881010     MOV W0, I2C1TRN
317:               
318:                               // determine the next state, check R/W
319:                               if (i2c_address & 0x01) {
000912  804310     MOV i2c_address, W0
000914  600061     AND W0, #0x1, W0
000916  784000     MOV.B W0, W0
000918  E00400     CP0.B W0
00091A  320003     BRA Z, 0x922
320:                                   // if this is a read we must repeat start
321:                                   // the bus to perform a read
322:                                   i2c1_state = S_MASTER_10BIT_RESTART;
00091C  2000B0     MOV #0xB, W0
00091E  8842D0     MOV W0, i2c1_state
323:                               } else {
324:                                   // this is a write continue writing data
325:                                   i2c1_state = S_MASTER_SEND_DATA;
000922  200030     MOV #0x3, W0
000924  8842D0     MOV W0, i2c1_state
326:                               }
327:                           }
328:               
329:                           break;
000906  3700B9     BRA 0xA7A
000920  3700AC     BRA 0xA7A
000926  3700A9     BRA 0xA7A
330:               
331:                       case S_MASTER_10BIT_RESTART:
332:               
333:                           if (I2C1_ACKNOWLEDGE_STATUS_BIT) {
000928  801041     MOV I2C1STAT, W1
00092A  280000     MOV #0x8000, W0
00092C  608000     AND W1, W0, W0
00092E  E00000     CP0 W0
000930  320008     BRA Z, 0x942
334:                               i2c1_object.i2cErrors++;
000932  208520     MOV #0x852, W0
000934  904060     MOV.B [W0+6], W0
000936  E84080     INC.B W0, W1
000938  208520     MOV #0x852, W0
00093A  984061     MOV.B W1, [W0+6]
335:                               I2C1_Stop(I2C1_MESSAGE_ADDRESS_NO_ACK);
00093C  200040     MOV #0x4, W0
00093E  0700B5     RCALL _I2C1_Stop
336:                           } else {
337:                               // ACK Status is good
338:                               // restart the bus
339:                               I2C1_REPEAT_START_CONDITION_ENABLE_BIT = 1;
000942  A82206     BSET I2C1CON, #1
340:               
341:                               // fudge the address so S_MASTER_SEND_ADDR works correctly
342:                               // we only do this on a 10-bit address resend
343:                               i2c_address = 0x00F0 | ((i2c_address >> 8) & 0x0006);
000944  804310     MOV i2c_address, W0
000946  DE0048     LSR W0, #8, W0
000948  6000E6     AND W0, #0x6, W1
00094A  200F00     MOV #0xF0, W0
00094C  700001     IOR W0, W1, W0
00094E  884310     MOV W0, i2c_address
344:               
345:                               // set the R/W flag
346:                               i2c_address |= 0x0001;
000950  804310     MOV i2c_address, W0
000952  A00000     BSET W0, #0
000954  884310     MOV W0, i2c_address
347:               
348:                               // set the address restart flag so we do not change the address
349:                               i2c_10bit_address_restart = 1;
000956  B3C010     MOV.B #0x1, W0
000958  B7E864     MOV.B WREG, i2c_10bit_address_restart
350:               
351:                               // Resend the address as a read
352:                               i2c1_state = S_MASTER_SEND_ADDR;
00095A  200020     MOV #0x2, W0
00095C  8842D0     MOV W0, i2c1_state
353:                           }
354:               
355:                           break;
000940  37009C     BRA 0xA7A
00095E  37008D     BRA 0xA7A
356:               
357:                       case S_MASTER_SEND_ADDR:
358:               
359:                           /* Start has been sent, send the address byte */
360:               
361:                           /* Note: 
362:                               On a 10-bit address resend (done only during a 10-bit
363:                               device read), the original i2c_address was modified in
364:                               S_MASTER_10BIT_RESTART state. So the check if this is
365:                               a 10-bit address will fail and a normal 7-bit address
366:                               is sent with the R/W bit set to read. The flag
367:                               i2c_10bit_address_restart prevents the  address to
368:                               be re-written.
369:                            */
370:                           if (i2c_10bit_address_restart != 1) {
000960  BFC864     MOV.B i2c_10bit_address_restart, WREG
000962  504FE1     SUB.B W0, #0x1, [W15]
000964  32000A     BRA Z, 0x97A
371:                               // extract the information for this message
372:                               i2c_address = p_i2c1_trb_current->address;
000966  8042F0     MOV p_i2c1_trb_current, W0
000968  780010     MOV [W0], W0
00096A  884310     MOV W0, i2c_address
373:                               pi2c_buf_ptr = p_i2c1_trb_current->pbuffer;
00096C  8042F0     MOV p_i2c1_trb_current, W0
00096E  900020     MOV [W0+4], W0
000970  884330     MOV W0, pi2c_buf_ptr
374:                               i2c_bytes_left = p_i2c1_trb_current->length;
000972  8042F0     MOV p_i2c1_trb_current, W0
000974  904020     MOV.B [W0+2], W0
000976  B7E868     MOV.B WREG, i2c_bytes_left
000978  370001     BRA 0x97C
375:                           } else {
376:                               // reset the flag so the next access is ok
377:                               i2c_10bit_address_restart = 0;
00097A  EF6864     CLR.B i2c_10bit_address_restart
378:                           }
379:               
380:                           // check for 10-bit address
381:                           if (i2c_address > 0x00FF) {
00097C  804311     MOV i2c_address, W1
00097E  200FF0     MOV #0xFF, W0
000980  508F80     SUB W1, W0, [W15]
000982  360009     BRA LEU, 0x996
382:                               // we have a 10 bit address
383:                               // send bits<9:8>
384:                               // mask bit 0 as this is always a write
385:                               I2C1_TRANSMIT_REG = 0xF0 | ((i2c_address >> 8) & 0x0006);
000984  804310     MOV i2c_address, W0
000986  DE0048     LSR W0, #8, W0
000988  6000E6     AND W0, #0x6, W1
00098A  200F00     MOV #0xF0, W0
00098C  700001     IOR W0, W1, W0
00098E  881010     MOV W0, I2C1TRN
386:                               i2c1_state = S_MASTER_SEND_ADDR_10BIT_LSB;
000990  2000A0     MOV #0xA, W0
000992  8842D0     MOV W0, i2c1_state
387:                           } else {
388:                               // Transmit the address
389:                               I2C1_TRANSMIT_REG = i2c_address;
000996  804310     MOV i2c_address, W0
000998  881010     MOV W0, I2C1TRN
390:                               if (i2c_address & 0x01) {
00099A  804310     MOV i2c_address, W0
00099C  600061     AND W0, #0x1, W0
00099E  784000     MOV.B W0, W0
0009A0  E00400     CP0.B W0
0009A2  320003     BRA Z, 0x9AA
391:                                   // Next state is to wait for address to be acked
392:                                   i2c1_state = S_MASTER_ACK_ADDR;
0009A4  200050     MOV #0x5, W0
0009A6  8842D0     MOV W0, i2c1_state
393:                               } else {
394:                                   // Next state is transmit
395:                                   i2c1_state = S_MASTER_SEND_DATA;
0009AA  200030     MOV #0x3, W0
0009AC  8842D0     MOV W0, i2c1_state
396:                               }
397:                           }
398:                           break;
000994  370072     BRA 0xA7A
0009A8  370068     BRA 0xA7A
0009AE  370065     BRA 0xA7A
399:               
400:                       case S_MASTER_SEND_DATA:
401:               
402:                           // Make sure the previous byte was acknowledged
403:                           if (I2C1_ACKNOWLEDGE_STATUS_BIT) {
0009B0  801041     MOV I2C1STAT, W1
0009B2  280000     MOV #0x8000, W0
0009B4  608000     AND W1, W0, W0
0009B6  E00000     CP0 W0
0009B8  320009     BRA Z, 0x9CC
404:                               // Transmission was not acknowledged
405:                               i2c1_object.i2cErrors++;
0009BA  208520     MOV #0x852, W0
0009BC  904060     MOV.B [W0+6], W0
0009BE  E84080     INC.B W0, W1
0009C0  208520     MOV #0x852, W0
0009C2  984061     MOV.B W1, [W0+6]
406:               
407:                               // Reset the Ack flag
408:                               I2C1_ACKNOWLEDGE_STATUS_BIT = 0;
0009C4  A9E209     BCLR 0x209, #7
409:               
410:                               // Send a stop flag and go back to idle
411:                               I2C1_Stop(I2C1_DATA_NO_ACK);
0009C6  200050     MOV #0x5, W0
0009C8  070070     RCALL _I2C1_Stop
412:               
413:                           } else {
414:                               // Did we send them all ?
415:                               if (i2c_bytes_left-- == 0U) {
0009CC  BFC868     MOV.B i2c_bytes_left, WREG
0009CE  FB8080     ZE W0, W1
0009D0  E90081     DEC W1, W1
0009D2  DE08CF     LSR W1, #15, W1
0009D4  784081     MOV.B W1, W1
0009D6  E94000     DEC.B W0, W0
0009D8  B7E868     MOV.B WREG, i2c_bytes_left
0009DA  E00401     CP0.B W1
0009DC  320010     BRA Z, 0x9FE
416:                                   // yup sent them all!
417:               
418:                                   // update the trb pointer
419:                                   p_i2c1_trb_current++;
0009DE  8042F0     MOV p_i2c1_trb_current, W0
0009E0  400066     ADD W0, #0x6, W0
0009E2  8842F0     MOV W0, p_i2c1_trb_current
420:               
421:                                   // are we done with this string of requests?
422:                                   if (--i2c1_trb_count == 0) {
0009E4  BFC85C     MOV.B i2c1_trb_count, WREG
0009E6  E94000     DEC.B W0, W0
0009E8  B7E85C     MOV.B WREG, i2c1_trb_count
0009EA  BFC85C     MOV.B i2c1_trb_count, WREG
0009EC  E00400     CP0.B W0
0009EE  3A0003     BRA NZ, 0x9F6
423:                                       I2C1_Stop(I2C1_MESSAGE_COMPLETE);
0009F0  200020     MOV #0x2, W0
0009F2  07005B     RCALL _I2C1_Stop
424:                                   } else {
425:                                       // no!, there are more TRB to be sent.
426:                                       //I2C1_START_CONDITION_ENABLE_BIT = 1;
427:               
428:                                       // In some cases, the slave may require
429:                                       // a restart instead of a start. So use this one
430:                                       // instead.
431:                                       I2C1_REPEAT_START_CONDITION_ENABLE_BIT = 1;
0009F6  A82206     BSET I2C1CON, #1
432:               
433:                                       // start the i2c request
434:                                       i2c1_state = S_MASTER_SEND_ADDR;
0009F8  200020     MOV #0x2, W0
0009FA  8842D0     MOV W0, i2c1_state
435:               
436:                                   }
437:                               } else {
438:                                   // Grab the next data to transmit
439:                                   I2C1_TRANSMIT_REG = *pi2c_buf_ptr++;
0009FE  804330     MOV pi2c_buf_ptr, W0
000A00  784090     MOV.B [W0], W1
000A02  FB8081     ZE W1, W1
000A04  881011     MOV W1, I2C1TRN
000A06  E80000     INC W0, W0
000A08  884330     MOV W0, pi2c_buf_ptr
440:                               }
441:                           }
442:                           break;
0009CA  370057     BRA 0xA7A
0009F4  370042     BRA 0xA7A
0009FC  37003E     BRA 0xA7A
000A0A  370037     BRA 0xA7A
443:               
444:                       case S_MASTER_ACK_ADDR:
445:               
446:                           /* Make sure the previous byte was acknowledged */
447:                           if (I2C1_ACKNOWLEDGE_STATUS_BIT) {
000A0C  801041     MOV I2C1STAT, W1
000A0E  280000     MOV #0x8000, W0
000A10  608000     AND W1, W0, W0
000A12  E00000     CP0 W0
000A14  320009     BRA Z, 0xA28
448:               
449:                               // Transmission was not acknowledged
450:                               i2c1_object.i2cErrors++;
000A16  208520     MOV #0x852, W0
000A18  904060     MOV.B [W0+6], W0
000A1A  E84080     INC.B W0, W1
000A1C  208520     MOV #0x852, W0
000A1E  984061     MOV.B W1, [W0+6]
451:               
452:                               // Send a stop flag and go back to idle
453:                               I2C1_Stop(I2C1_MESSAGE_ADDRESS_NO_ACK);
000A20  200040     MOV #0x4, W0
000A22  070043     RCALL _I2C1_Stop
454:               
455:                               // Reset the Ack flag
456:                               I2C1_ACKNOWLEDGE_STATUS_BIT = 0;
000A24  A9E209     BCLR 0x209, #7
457:                           } else {
458:                               I2C1_RECEIVE_ENABLE_BIT = 1;
000A28  A86206     BSET I2C1CON, #3
459:                               i2c1_state = S_MASTER_ACK_RCV_DATA;
000A2A  200080     MOV #0x8, W0
000A2C  8842D0     MOV W0, i2c1_state
460:                           }
461:                           break;
000A26  370029     BRA 0xA7A
000A2E  370025     BRA 0xA7A
462:               
463:                       case S_MASTER_RCV_DATA:
464:               
465:                           /* Acknowledge is completed.  Time for more data */
466:               
467:                           // Next thing is to ack the data
468:                           i2c1_state = S_MASTER_ACK_RCV_DATA;
000A30  200080     MOV #0x8, W0
000A32  8842D0     MOV W0, i2c1_state
469:               
470:                           // Set up to receive a byte of data
471:                           I2C1_RECEIVE_ENABLE_BIT = 1;
000A34  A86206     BSET I2C1CON, #3
472:               
473:                           break;
000A36  370021     BRA 0xA7A
474:               
475:                       case S_MASTER_ACK_RCV_DATA:
476:               
477:                           // Grab the byte of data received and acknowledge it
478:                           *pi2c_buf_ptr++ = I2C1_RECEIVE_REG;
000A38  804330     MOV pi2c_buf_ptr, W0
000A3A  801001     MOV I2C1RCV, W1
000A3C  784081     MOV.B W1, W1
000A3E  784801     MOV.B W1, [W0]
000A40  E80000     INC W0, W0
000A42  884330     MOV W0, pi2c_buf_ptr
479:               
480:                           // Check if we received them all?
481:                           if (--i2c_bytes_left) {
000A44  BFC868     MOV.B i2c_bytes_left, WREG
000A46  E94000     DEC.B W0, W0
000A48  B7E868     MOV.B WREG, i2c_bytes_left
000A4A  BFC868     MOV.B i2c_bytes_left, WREG
000A4C  E00400     CP0.B W0
000A4E  320004     BRA Z, 0xA58
482:               
483:                               /* No, there's more to receive */
484:               
485:                               // No, bit 7 is clear.  Data is ok
486:                               // Set the flag to acknowledge the data
487:                               I2C1_ACKNOWLEDGE_DATA_BIT = 0;
000A50  A9A206     BCLR I2C1CON, #5
488:               
489:                               // Wait for the acknowledge to complete, then get more
490:                               i2c1_state = S_MASTER_RCV_DATA;
000A52  200060     MOV #0x6, W0
000A54  8842D0     MOV W0, i2c1_state
000A56  370002     BRA 0xA5C
491:                           } else {
492:               
493:                               // Yes, it's the last byte.  Don't ack it
494:                               // Flag that we will nak the data
495:                               I2C1_ACKNOWLEDGE_DATA_BIT = 1;
000A58  A8A206     BSET I2C1CON, #5
496:               
497:                               I2C1_FunctionComplete();
000A5A  070016     RCALL _I2C1_FunctionComplete
498:                           }
499:               
500:                           // Initiate the acknowledge
501:                           I2C1_ACKNOWLEDGE_ENABLE_BIT = 1;
000A5C  A88206     BSET I2C1CON, #4
502:                           break;
000A5E  37000D     BRA 0xA7A
503:               
504:                       case S_MASTER_RCV_STOP:
505:                       case S_MASTER_SEND_STOP:
506:               
507:                           // Send the stop flag
508:                           I2C1_Stop(I2C1_MESSAGE_COMPLETE);
000A60  200020     MOV #0x2, W0
000A62  070023     RCALL _I2C1_Stop
509:                           break;
000A64  37000A     BRA 0xA7A
510:               
511:                       default:
512:               
513:                           // This case should not happen, if it does then
514:                           // terminate the transfer
515:                           i2c1_object.i2cErrors++;
000A66  208520     MOV #0x852, W0
000A68  904060     MOV.B [W0+6], W0
000A6A  E84080     INC.B W0, W1
000A6C  208520     MOV #0x852, W0
000A6E  984061     MOV.B W1, [W0+6]
516:                           I2C1_Stop(I2C1_LOST_STATE);
000A70  200060     MOV #0x6, W0
000A72  07001B     RCALL _I2C1_Stop
517:                           break;
000A74  000000     NOP
000A76  370001     BRA 0xA7A
518:               
519:                   }
520:               }
000A7A  FA8000     ULNK
000A7C  BE034F     MOV.D [--W15], W6
000A7E  BE024F     MOV.D [--W15], W4
000A80  BE014F     MOV.D [--W15], W2
000A82  BE004F     MOV.D [--W15], W0
000A84  F90036     POP RCOUNT
000A86  064000     RETFIE
521:               
522:               static void I2C1_FunctionComplete(void) {
000A88  FA0000     LNK #0x0
523:               
524:                   // update the trb pointer
525:                   p_i2c1_trb_current++;
000A8A  8042F0     MOV p_i2c1_trb_current, W0
000A8C  400066     ADD W0, #0x6, W0
000A8E  8842F0     MOV W0, p_i2c1_trb_current
526:               
527:                   // are we done with this string of requests?
528:                   if (--i2c1_trb_count == 0) {
000A90  BFC85C     MOV.B i2c1_trb_count, WREG
000A92  E94000     DEC.B W0, W0
000A94  B7E85C     MOV.B WREG, i2c1_trb_count
000A96  BFC85C     MOV.B i2c1_trb_count, WREG
000A98  E00400     CP0.B W0
000A9A  3A0003     BRA NZ, 0xAA2
529:                       i2c1_state = S_MASTER_SEND_STOP;
000A9C  200040     MOV #0x4, W0
000A9E  8842D0     MOV W0, i2c1_state
000AA0  370002     BRA 0xAA6
530:                   } else {
531:                       i2c1_state = S_MASTER_RESTART;
000AA2  200010     MOV #0x1, W0
000AA4  8842D0     MOV W0, i2c1_state
532:                   }
533:               
534:               }
000AA6  FA8000     ULNK
000AA8  060000     RETURN
535:               
536:               static void I2C1_Stop(I2C1_MESSAGE_STATUS completion_code) {
000AAA  FA0002     LNK #0x2
000AAC  780F00     MOV W0, [W14]
537:                   // then send a stop
538:                   I2C1_STOP_CONDITION_ENABLE_BIT = 1;
000AAE  A84206     BSET I2C1CON, #2
539:               
540:                   // make sure the flag pointer is not NULL
541:                   if (p_i2c1_current->pTrFlag != NULL) {
000AB0  804300     MOV p_i2c1_current, W0
000AB2  900020     MOV [W0+4], W0
000AB4  E00000     CP0 W0
000AB6  320003     BRA Z, 0xABE
542:                       // update the flag with the completion code
543:                       *(p_i2c1_current->pTrFlag) = completion_code;
000AB8  804300     MOV p_i2c1_current, W0
000ABA  900020     MOV [W0+4], W0
000ABC  78081E     MOV [W14], [W0]
544:                   }
545:               
546:                   // Done, back to idle
547:                   i2c1_state = S_MASTER_IDLE;
000ABE  EF285A     CLR i2c1_state
548:               
549:               }
000AC0  FA8000     ULNK
000AC2  060000     RETURN
000AC4  FA0008     LNK #0x8
000AC6  780F00     MOV W0, [W14]
000AC8  984721     MOV.B W1, [W14+2]
000ACA  980722     MOV W2, [W14+4]
000ACC  980733     MOV W3, [W14+6]
550:               
551:               void I2C1_MasterWrite(
552:                       uint8_t *pdata,
553:                       uint8_t length,
554:                       uint16_t address,
555:                       I2C1_MESSAGE_STATUS *pstatus) {
000AC4  FA0008     LNK #0x8
556:                   static I2C1_TRANSACTION_REQUEST_BLOCK trBlock;
557:               
558:                   // check if there is space in the queue
559:                   if (i2c1_object.trStatus.s.full != true) {
000ACE  208520     MOV #0x852, W0
000AD0  900020     MOV [W0+4], W0
000AD2  600061     AND W0, #0x1, W0
000AD4  E00000     CP0 W0
000AD6  3A000A     BRA NZ, 0xAEC
560:                       I2C1_MasterWriteTRBBuild(&trBlock, pdata, length, address);
000AD8  9001AE     MOV [W14+4], W3
000ADA  90412E     MOV.B [W14+2], W2
000ADC  78009E     MOV [W14], W1
000ADE  20CA20     MOV #0xCA2, W0
000AE0  0700C2     RCALL I2C1_MasterWriteTRBBuild
561:                       I2C1_MasterTRBInsert(1, &trBlock, pstatus);
000AE2  90013E     MOV [W14+6], W2
000AE4  20CA21     MOV #0xCA2, W1
000AE6  B3C010     MOV.B #0x1, W0
000AE8  070053     RCALL I2C1_MasterTRBInsert
000AEA  370003     BRA 0xAF2
562:                   } else {
563:                       *pstatus = I2C1_MESSAGE_FAIL;
000AEC  90003E     MOV [W14+6], W0
000AEE  EB0080     CLR W1
000AF0  780801     MOV W1, [W0]
564:                   }
565:               
566:               }
000AF2  FA8000     ULNK
000AF4  060000     RETURN
000AF6  FA0008     LNK #0x8
000AF8  780F00     MOV W0, [W14]
000AFA  984721     MOV.B W1, [W14+2]
000AFC  980722     MOV W2, [W14+4]
000AFE  980733     MOV W3, [W14+6]
567:               
568:               void I2C1_si7020request(uint8_t *command, uint8_t length, uint16_t adress, I2C1_MESSAGE_STATUS *pstatus) {
000AF6  FA0008     LNK #0x8
569:                   static I2C1_TRANSACTION_REQUEST_BLOCK trBlock;
570:               
571:                   // check if there is space in the queue
572:                   if (i2c1_object.trStatus.s.full != true) {
000B00  208520     MOV #0x852, W0
000B02  900020     MOV [W0+4], W0
000B04  600061     AND W0, #0x1, W0
000B06  E00000     CP0 W0
000B08  3A000A     BRA NZ, 0xB1E
573:                       I2C1_MasterWriteTRBBuild(&trBlock, command, length, adress);
000B0A  9001AE     MOV [W14+4], W3
000B0C  90412E     MOV.B [W14+2], W2
000B0E  78009E     MOV [W14], W1
000B10  20C9C0     MOV #0xC9C, W0
000B12  0700A9     RCALL I2C1_MasterWriteTRBBuild
574:                       I2C1_MasterTRBInsert(1, &trBlock, pstatus);
000B14  90013E     MOV [W14+6], W2
000B16  20C9C1     MOV #0xC9C, W1
000B18  B3C010     MOV.B #0x1, W0
000B1A  07003A     RCALL I2C1_MasterTRBInsert
000B1C  370003     BRA 0xB24
575:                   } else {
576:                       *pstatus = I2C1_MESSAGE_FAIL;
000B1E  90003E     MOV [W14+6], W0
000B20  EB0080     CLR W1
000B22  780801     MOV W1, [W0]
577:                   }
578:               
579:               
580:               
581:               }
000B24  FA8000     ULNK
000B26  060000     RETURN
582:               
583:               void I2C1_si7020Start() {
000B28  FA0000     LNK #0x0
584:               
585:               }
000B2A  FA8000     ULNK
000B2C  060000     RETURN
586:               
587:               void DRV_I2C1_MasterWrite(
588:                       uint8_t *pdata,
589:                       uint8_t length,
590:                       uint16_t address,
591:                       DRV_I2C1_MESSAGE_STATUS *pstatus) {
000B2E  FA0008     LNK #0x8
000B30  780F00     MOV W0, [W14]
000B32  984721     MOV.B W1, [W14+2]
000B34  980722     MOV W2, [W14+4]
000B36  980733     MOV W3, [W14+6]
592:                   I2C1_MasterWrite(pdata, length, address, (I2C1_MESSAGE_STATUS *) pstatus);
000B38  9001BE     MOV [W14+6], W3
000B3A  90012E     MOV [W14+4], W2
000B3C  9040AE     MOV.B [W14+2], W1
000B3E  78001E     MOV [W14], W0
000B40  07FFC1     RCALL I2C1_MasterWrite
593:               }
000B42  FA8000     ULNK
000B44  060000     RETURN
594:               
595:               void I2C1_MasterRead(
596:                       uint8_t *pdata,
597:                       uint8_t length,
598:                       uint16_t address,
599:                       I2C1_MESSAGE_STATUS *pstatus) {
000B46  FA0008     LNK #0x8
000B48  780F00     MOV W0, [W14]
000B4A  984721     MOV.B W1, [W14+2]
000B4C  980722     MOV W2, [W14+4]
000B4E  980733     MOV W3, [W14+6]
600:                   static I2C1_TRANSACTION_REQUEST_BLOCK trBlock;
601:               
602:               
603:                   // check if there is space in the queue
604:                   if (i2c1_object.trStatus.s.full != true) {
000B50  208520     MOV #0x852, W0
000B52  900020     MOV [W0+4], W0
000B54  600061     AND W0, #0x1, W0
000B56  E00000     CP0 W0
000B58  3A000A     BRA NZ, 0xB6E
605:                       I2C1_MasterReadTRBBuild(&trBlock, pdata, length, address);
000B5A  9001AE     MOV [W14+4], W3
000B5C  90412E     MOV.B [W14+2], W2
000B5E  78009E     MOV [W14], W1
000B60  20C960     MOV #0xC96, W0
000B62  07005D     RCALL I2C1_MasterReadTRBBuild
606:                       I2C1_MasterTRBInsert(1, &trBlock, pstatus);
000B64  90013E     MOV [W14+6], W2
000B66  20C961     MOV #0xC96, W1
000B68  B3C010     MOV.B #0x1, W0
000B6A  070012     RCALL I2C1_MasterTRBInsert
000B6C  370003     BRA 0xB74
607:                   } else {
608:                       *pstatus = I2C1_MESSAGE_FAIL;
000B6E  90003E     MOV [W14+6], W0
000B70  EB0080     CLR W1
000B72  780801     MOV W1, [W0]
609:                   }
610:               
611:               }
000B74  FA8000     ULNK
000B76  060000     RETURN
612:               
613:               void DRV_I2C1_MasterRead(
614:                       uint8_t *pdata,
615:                       uint8_t length,
616:                       uint16_t address,
617:                       DRV_I2C1_MESSAGE_STATUS *pstatus) {
000B78  FA0008     LNK #0x8
000B7A  780F00     MOV W0, [W14]
000B7C  984721     MOV.B W1, [W14+2]
000B7E  980722     MOV W2, [W14+4]
000B80  980733     MOV W3, [W14+6]
618:                   I2C1_MasterRead(pdata, length, address, (I2C1_MESSAGE_STATUS *) pstatus);
000B82  9001BE     MOV [W14+6], W3
000B84  90012E     MOV [W14+4], W2
000B86  9040AE     MOV.B [W14+2], W1
000B88  78001E     MOV [W14], W0
000B8A  07FFDD     RCALL I2C1_MasterRead
619:               }
000B8C  FA8000     ULNK
000B8E  060000     RETURN
000B90  FA0006     LNK #0x6
000B92  784F00     MOV.B W0, [W14]
000B94  980711     MOV W1, [W14+2]
000B96  980722     MOV W2, [W14+4]
620:               
621:               void I2C1_MasterTRBInsert(
622:                       uint8_t count,
623:                       I2C1_TRANSACTION_REQUEST_BLOCK *ptrb_list,
624:                       I2C1_MESSAGE_STATUS *pflag) {
000B90  FA0006     LNK #0x6
625:               
626:                   // check if there is space in the queue
627:                   if (i2c1_object.trStatus.s.full != true) {
000B98  208520     MOV #0x852, W0
000B9A  900020     MOV [W0+4], W0
000B9C  600061     AND W0, #0x1, W0
000B9E  E00000     CP0 W0
000BA0  3A002E     BRA NZ, 0xBFE
628:                       *pflag = I2C1_MESSAGE_PENDING;
000BA2  90002E     MOV [W14+4], W0
000BA4  200011     MOV #0x1, W1
000BA6  780801     MOV W1, [W0]
629:               
630:                       i2c1_object.pTrTail->ptrb_list = ptrb_list;
000BA8  208520     MOV #0x852, W0
000BAA  780010     MOV [W0], W0
000BAC  90009E     MOV [W14+2], W1
000BAE  980011     MOV W1, [W0+2]
631:                       i2c1_object.pTrTail->count = count;
000BB0  208520     MOV #0x852, W0
000BB2  780010     MOV [W0], W0
000BB4  78481E     MOV.B [W14], [W0]
632:                       i2c1_object.pTrTail->pTrFlag = pflag;
000BB6  208520     MOV #0x852, W0
000BB8  780010     MOV [W0], W0
000BBA  9000AE     MOV [W14+4], W1
000BBC  980021     MOV W1, [W0+4]
633:                       i2c1_object.pTrTail++;
000BBE  208520     MOV #0x852, W0
000BC0  780010     MOV [W0], W0
000BC2  4000E6     ADD W0, #0x6, W1
000BC4  208520     MOV #0x852, W0
000BC6  780801     MOV W1, [W0]
634:               
635:                       // check if the end of the array is reached
636:                       if (i2c1_object.pTrTail == (i2c1_tr_queue + I2C1_CONFIG_TR_QUEUE_LENGTH)) {
000BC8  208520     MOV #0x852, W0
000BCA  780090     MOV [W0], W1
000BCC  20C960     MOV #0xC96, W0
000BCE  508F80     SUB W1, W0, [W15]
000BD0  3A0003     BRA NZ, 0xBD8
637:                           // adjust to restart at the beginning of the array
638:                           i2c1_object.pTrTail = i2c1_tr_queue;
000BD2  208520     MOV #0x852, W0
000BD4  20C901     MOV #0xC90, W1
000BD6  780801     MOV W1, [W0]
639:                       }
640:               
641:                       // since we added one item to be processed, we know
642:                       // it is not empty, so set the empty status to false
643:                       i2c1_object.trStatus.s.empty = false;
000BD8  208521     MOV #0x852, W1
000BDA  900021     MOV [W1+4], W0
000BDC  A11000     BCLR W0, #1
000BDE  9800A0     MOV W0, [W1+4]
644:               
645:                       // check if full
646:                       if (i2c1_object.pTrHead == i2c1_object.pTrTail) {
000BE0  208520     MOV #0x852, W0
000BE2  900090     MOV [W0+2], W1
000BE4  208520     MOV #0x852, W0
000BE6  780010     MOV [W0], W0
000BE8  508F80     SUB W1, W0, [W15]
000BEA  3A0004     BRA NZ, 0xBF4
647:                           // it is full, set the full status to true
648:                           i2c1_object.trStatus.s.full = true;
000BEC  208521     MOV #0x852, W1
000BEE  900021     MOV [W1+4], W0
000BF0  A00000     BSET W0, #0
000BF2  9800A0     MOV W0, [W1+4]
649:                       }
650:               
651:                       // for interrupt based
652:                       if (i2c1_state == S_MASTER_IDLE) {
000BF4  8042D0     MOV i2c1_state, W0
000BF6  E00000     CP0 W0
000BF8  3A0005     BRA NZ, 0xC04
653:                           // force the task to run since we know that the queue has
654:                           // something that needs to be sent
655:                           IFS1bits.MI2C1IF = 1;
000BFA  A82086     BSET IFS1, #1
000BFC  370003     BRA 0xC04
656:                       }
657:               
658:                   } else {
659:                       *pflag = I2C1_MESSAGE_FAIL;
000BFE  90002E     MOV [W14+4], W0
000C00  EB0080     CLR W1
000C02  780801     MOV W1, [W0]
660:                   }
661:               
662:               }
000C04  FA8000     ULNK
000C06  060000     RETURN
663:               
664:               void DRV_I2C1_MasterTRBInsert(
665:                       uint8_t count,
666:                       DRV_I2C1_TRANSACTION_REQUEST_BLOCK *ptrb_list,
667:                       DRV_I2C1_MESSAGE_STATUS *pflag) {
000C08  FA0006     LNK #0x6
000C0A  784F00     MOV.B W0, [W14]
000C0C  980711     MOV W1, [W14+2]
000C0E  980722     MOV W2, [W14+4]
668:                   I2C1_MasterTRBInsert(count, (I2C1_TRANSACTION_REQUEST_BLOCK *) ptrb_list, (I2C1_MESSAGE_STATUS *) pflag);
000C10  90001E     MOV [W14+2], W0
000C12  90012E     MOV [W14+4], W2
000C14  780080     MOV W0, W1
000C16  78401E     MOV.B [W14], W0
000C18  07FFBB     RCALL I2C1_MasterTRBInsert
669:               }
000C1A  FA8000     ULNK
000C1C  060000     RETURN
000C1E  FA0008     LNK #0x8
000C20  780F00     MOV W0, [W14]
000C22  980711     MOV W1, [W14+2]
000C24  984742     MOV.B W2, [W14+4]
000C26  980733     MOV W3, [W14+6]
670:               
671:               void I2C1_MasterReadTRBBuild(
672:                       I2C1_TRANSACTION_REQUEST_BLOCK *ptrb,
673:                       uint8_t *pdata,
674:                       uint8_t length,
675:                       uint16_t address) {
000C1E  FA0008     LNK #0x8
676:                   ptrb->address = address << 1;
000C28  90003E     MOV [W14+6], W0
000C2A  400000     ADD W0, W0, W0
000C2C  780080     MOV W0, W1
000C2E  78001E     MOV [W14], W0
000C30  780801     MOV W1, [W0]
677:                   // make this a read
678:                   ptrb->address |= 0x01;
000C32  78001E     MOV [W14], W0
000C34  780010     MOV [W0], W0
000C36  780080     MOV W0, W1
000C38  A00001     BSET W1, #0
000C3A  78001E     MOV [W14], W0
000C3C  780801     MOV W1, [W0]
679:                   ptrb->length = length;
000C3E  78001E     MOV [W14], W0
000C40  9040CE     MOV.B [W14+4], W1
000C42  984021     MOV.B W1, [W0+2]
680:                   ptrb->pbuffer = pdata;
000C44  78001E     MOV [W14], W0
000C46  90009E     MOV [W14+2], W1
000C48  980021     MOV W1, [W0+4]
681:               }
000C4A  FA8000     ULNK
000C4C  060000     RETURN
000C4E  FA0008     LNK #0x8
000C50  780F00     MOV W0, [W14]
000C52  980711     MOV W1, [W14+2]
000C54  984742     MOV.B W2, [W14+4]
000C56  980733     MOV W3, [W14+6]
682:               
683:               void DRV_I2C1_MasterReadTRBBuild(
684:                       DRV_I2C1_TRANSACTION_REQUEST_BLOCK *ptrb,
685:                       uint8_t *pdata,
686:                       uint8_t length,
687:                       uint16_t address) {
000C4E  FA0008     LNK #0x8
688:                   I2C1_MasterReadTRBBuild((I2C1_TRANSACTION_REQUEST_BLOCK *) ptrb, pdata, length, address);
000C58  78001E     MOV [W14], W0
000C5A  9001BE     MOV [W14+6], W3
000C5C  90414E     MOV.B [W14+4], W2
000C5E  90009E     MOV [W14+2], W1
000C60  07FFDE     RCALL I2C1_MasterReadTRBBuild
689:               }
000C62  FA8000     ULNK
000C64  060000     RETURN
000C66  FA0008     LNK #0x8
000C68  780F00     MOV W0, [W14]
000C6A  980711     MOV W1, [W14+2]
000C6C  984742     MOV.B W2, [W14+4]
000C6E  980733     MOV W3, [W14+6]
690:               
691:               void I2C1_MasterWriteTRBBuild(
692:                       I2C1_TRANSACTION_REQUEST_BLOCK *ptrb,
693:                       uint8_t *pdata,
694:                       uint8_t length,
695:                       uint16_t address) {
000C66  FA0008     LNK #0x8
696:                   ptrb->address = address << 1;
000C70  90003E     MOV [W14+6], W0
000C72  400000     ADD W0, W0, W0
000C74  780080     MOV W0, W1
000C76  78001E     MOV [W14], W0
000C78  780801     MOV W1, [W0]
697:                   ptrb->length = length;
000C7A  78001E     MOV [W14], W0
000C7C  9040CE     MOV.B [W14+4], W1
000C7E  984021     MOV.B W1, [W0+2]
698:                   ptrb->pbuffer = pdata;
000C80  78001E     MOV [W14], W0
000C82  90009E     MOV [W14+2], W1
000C84  980021     MOV W1, [W0+4]
699:               }
000C86  FA8000     ULNK
000C88  060000     RETURN
000C8A  FA0008     LNK #0x8
000C8C  780F00     MOV W0, [W14]
000C8E  980711     MOV W1, [W14+2]
000C90  984742     MOV.B W2, [W14+4]
000C92  980733     MOV W3, [W14+6]
700:               
701:               void DRV_I2C1_MasterWriteTRBBuild(
702:                       DRV_I2C1_TRANSACTION_REQUEST_BLOCK *ptrb,
703:                       uint8_t *pdata,
704:                       uint8_t length,
705:                       uint16_t address) {
000C8A  FA0008     LNK #0x8
706:                   I2C1_MasterWriteTRBBuild((I2C1_TRANSACTION_REQUEST_BLOCK *) ptrb, pdata, length, address);
000C94  78001E     MOV [W14], W0
000C96  9001BE     MOV [W14+6], W3
000C98  90414E     MOV.B [W14+4], W2
000C9A  90009E     MOV [W14+2], W1
000C9C  07FFE4     RCALL I2C1_MasterWriteTRBBuild
707:               }
000C9E  FA8000     ULNK
000CA0  060000     RETURN
708:               
709:               bool I2C1_MasterQueueIsEmpty(void) {
000CA2  FA0000     LNK #0x0
710:                   return (i2c1_object.trStatus.s.empty);
000CA4  208520     MOV #0x852, W0
000CA6  900020     MOV [W0+4], W0
000CA8  D10000     LSR W0, W0
000CAA  604061     AND.B W0, #0x1, W0
000CAC  FB8000     ZE W0, W0
000CAE  A7F000     BTSC W0, #15
000CB0  EA0000     NEG W0, W0
000CB2  EA0000     NEG W0, W0
000CB4  DE004F     LSR W0, #15, W0
000CB6  784000     MOV.B W0, W0
711:               }
000CB8  FA8000     ULNK
000CBA  060000     RETURN
712:               
713:               bool DRV_I2C1_MasterQueueIsEmpty(void) {
000CBC  FA0000     LNK #0x0
714:                   return I2C1_MasterQueueIsEmpty();
000CBE  07FFF1     RCALL I2C1_MasterQueueIsEmpty
715:               }
000CC0  FA8000     ULNK
000CC2  060000     RETURN
716:               
717:               bool I2C1_MasterQueueIsFull(void) {
000CC4  FA0000     LNK #0x0
718:                   return (i2c1_object.trStatus.s.full);
000CC6  208520     MOV #0x852, W0
000CC8  900020     MOV [W0+4], W0
000CCA  604061     AND.B W0, #0x1, W0
000CCC  FB8000     ZE W0, W0
000CCE  A7F000     BTSC W0, #15
000CD0  EA0000     NEG W0, W0
000CD2  EA0000     NEG W0, W0
000CD4  DE004F     LSR W0, #15, W0
000CD6  784000     MOV.B W0, W0
719:               }
000CD8  FA8000     ULNK
000CDA  060000     RETURN
720:               
721:               bool DRV_I2C1_MasterQueueIsFull(void) {
000CDC  FA0000     LNK #0x0
722:                   return I2C1_MasterQueueIsFull();
000CDE  07FFF2     RCALL I2C1_MasterQueueIsFull
723:               }
000CE0  FA8000     ULNK
000CE2  060000     RETURN
000CE4  FA0014     LNK #0x14
000CE6  980770     MOV W0, [W14+14]
000CE8  980F01     MOV W1, [W14+16]
000CEA  980F12     MOV W2, [W14+18]
724:               
725:               #define MCHP24AA512_RETRY_MAX       100  // define the retry count
726:               #define MCHP24AA512_ADDRESS         0x40 // slave device address
727:               #define MCHP24AA512_DEVICE_TIMEOUT  50   // define slave timeout 
728:               
729:               uint8_t MCHP24AA512_Read(
730:                       uint16_t address,
731:                       uint8_t *pData,
732:                       uint16_t nCount) {
000CE4  FA0014     LNK #0x14
733:                   I2C1_MESSAGE_STATUS status;
734:                   uint8_t writeBuffer[3];
735:                   uint16_t retryTimeOut, slaveTimeOut;
736:                   uint16_t counter;
737:                   uint8_t *pD;
738:               
739:                   pD = pData;
000CEC  90088E     MOV [W14+16], W1
000CEE  980731     MOV W1, [W14+6]
740:               
741:                   for (counter = 0; counter < nCount; counter++) {
000CF0  EB0000     CLR W0
000CF2  980720     MOV W0, [W14+4]
000CF4  370066     BRA 0xDC2
000DBC  90002E     MOV [W14+4], W0
000DBE  E80000     INC W0, W0
000DC0  980720     MOV W0, [W14+4]
000DC2  9000AE     MOV [W14+4], W1
000DC4  90081E     MOV [W14+18], W0
000DC6  508F80     SUB W1, W0, [W15]
000DC8  39FF96     BRA NC, 0xCF6
742:               
743:                       // build the write buffer first
744:                       // starting address of the EEPROM memory
745:                       writeBuffer[0] = (address >> 8); // high address
000CF6  90007E     MOV [W14+14], W0
000CF8  DE0048     LSR W0, #8, W0
000CFA  784000     MOV.B W0, W0
000CFC  984F20     MOV.B W0, [W14+10]
746:                       writeBuffer[1] = (uint8_t) (address); // low low address
000CFE  90007E     MOV [W14+14], W0
000D00  784000     MOV.B W0, W0
000D02  984F30     MOV.B W0, [W14+11]
747:               
748:                       // Now it is possible that the slave device will be slow.
749:                       // As a work around on these slaves, the application can
750:                       // retry sending the transaction
751:                       retryTimeOut = 0;
000D04  EB0000     CLR W0
000D06  780F00     MOV W0, [W14]
752:                       slaveTimeOut = 0;
000D08  EB0000     CLR W0
000D0A  980710     MOV W0, [W14+2]
753:               
754:                       while (status != I2C1_MESSAGE_FAIL) {
000D0C  37001B     BRA 0xD44
000D44  90004E     MOV [W14+8], W0
000D46  E00000     CP0 W0
000D48  3AFFE2     BRA NZ, 0xD0E
000D4A  370003     BRA 0xD52
755:                           // write one byte to EEPROM (2 is the count of bytes to write)
756:                           I2C1_MasterWrite(writeBuffer,
000D0E  4700E8     ADD W14, #0x8, W1
000D10  47006A     ADD W14, #0xA, W0
000D12  780181     MOV W1, W3
000D14  200402     MOV #0x40, W2
000D16  B3C021     MOV.B #0x2, W1
000D18  07FED5     RCALL I2C1_MasterWrite
757:                                   2,
758:                                   MCHP24AA512_ADDRESS,
759:                                   &status);
760:               
761:                           // wait for the message to be sent or status has changed.
762:                           while (status == I2C1_MESSAGE_PENDING) {
000D1A  370009     BRA 0xD2E
000D2E  90004E     MOV [W14+8], W0
000D30  500FE1     SUB W0, #0x1, [W15]
000D32  32FFF4     BRA Z, 0xD1C
763:                               // add some delay here
764:               
765:                               // timeout checking
766:                               // check for max retry and skip this byte
767:                               if (slaveTimeOut == MCHP24AA512_DEVICE_TIMEOUT)
000D1C  90009E     MOV [W14+2], W1
000D1E  200320     MOV #0x32, W0
000D20  508F80     SUB W1, W0, [W15]
000D22  3A0002     BRA NZ, 0xD28
768:                                   return (0);
000D24  EB4000     CLR.B W0
000D26  370052     BRA 0xDCC
769:                               else
770:                                   slaveTimeOut++;
000D28  90001E     MOV [W14+2], W0
000D2A  E80000     INC W0, W0
000D2C  980710     MOV W0, [W14+2]
771:                           }
772:               
773:                           if (status == I2C1_MESSAGE_COMPLETE)
000D34  90004E     MOV [W14+8], W0
000D36  500FE2     SUB W0, #0x2, [W15]
000D38  320009     BRA Z, 0xD4C
774:                               break;
000D4C  000000     NOP
000D4E  370001     BRA 0xD52
775:               
776:                           // if status is  I2C1_MESSAGE_ADDRESS_NO_ACK,
777:                           //               or I2C1_DATA_NO_ACK,
778:                           // The device may be busy and needs more time for the last
779:                           // write so we can retry writing the data, this is why we
780:                           // use a while loop here
781:               
782:                           // check for max retry and skip this byte
783:                           if (retryTimeOut == MCHP24AA512_RETRY_MAX)
000D3A  200640     MOV #0x64, W0
000D3C  78009E     MOV [W14], W1
000D3E  508F80     SUB W1, W0, [W15]
000D40  320007     BRA Z, 0xD50
784:                               break;
000D50  000000     NOP
785:                           else
786:                               retryTimeOut++;
000D42  E80F1E     INC [W14], [W14]
787:                       }
788:               
789:                       if (status == I2C1_MESSAGE_COMPLETE) {
000D52  90004E     MOV [W14+8], W0
000D54  500FE2     SUB W0, #0x2, [W15]
000D56  3A0027     BRA NZ, 0xDA6
790:               
791:                           // this portion will read the byte from the memory location.
792:                           retryTimeOut = 0;
000D58  EB0000     CLR W0
000D5A  780F00     MOV W0, [W14]
793:                           slaveTimeOut = 0;
000D5C  EB0000     CLR W0
000D5E  980710     MOV W0, [W14+2]
794:               
795:                           while (status != I2C1_MESSAGE_FAIL) {
000D60  37001B     BRA 0xD98
000D98  90004E     MOV [W14+8], W0
000D9A  E00000     CP0 W0
000D9C  3AFFE2     BRA NZ, 0xD62
000D9E  370003     BRA 0xDA6
796:                               // write one byte to EEPROM (2 is the count of bytes to write)
797:                               I2C1_MasterRead(pD,
000D62  470068     ADD W14, #0x8, W0
000D64  780180     MOV W0, W3
000D66  200402     MOV #0x40, W2
000D68  B3C011     MOV.B #0x1, W1
000D6A  90003E     MOV [W14+6], W0
000D6C  07FEEC     RCALL I2C1_MasterRead
798:                                       1,
799:                                       MCHP24AA512_ADDRESS,
800:                                       &status);
801:               
802:                               // wait for the message to be sent or status has changed.
803:                               while (status == I2C1_MESSAGE_PENDING) {
000D6E  370009     BRA 0xD82
000D82  90004E     MOV [W14+8], W0
000D84  500FE1     SUB W0, #0x1, [W15]
000D86  32FFF4     BRA Z, 0xD70
804:                                   // add some delay here
805:               
806:                                   // timeout checking
807:                                   // check for max retry and skip this byte
808:                                   if (slaveTimeOut == MCHP24AA512_DEVICE_TIMEOUT)
000D70  90009E     MOV [W14+2], W1
000D72  200320     MOV #0x32, W0
000D74  508F80     SUB W1, W0, [W15]
000D76  3A0002     BRA NZ, 0xD7C
809:                                       return (0);
000D78  EB4000     CLR.B W0
000D7A  370028     BRA 0xDCC
810:                                   else
811:                                       slaveTimeOut++;
000D7C  90001E     MOV [W14+2], W0
000D7E  E80000     INC W0, W0
000D80  980710     MOV W0, [W14+2]
812:                               }
813:               
814:                               if (status == I2C1_MESSAGE_COMPLETE)
000D88  90004E     MOV [W14+8], W0
000D8A  500FE2     SUB W0, #0x2, [W15]
000D8C  320009     BRA Z, 0xDA0
815:                                   break;
000DA0  000000     NOP
000DA2  370001     BRA 0xDA6
816:               
817:                               // if status is  I2C1_MESSAGE_ADDRESS_NO_ACK,
818:                               //               or I2C1_DATA_NO_ACK,
819:                               // The device may be busy and needs more time for the last
820:                               // write so we can retry writing the data, this is why we
821:                               // use a while loop here
822:               
823:                               // check for max retry and skip this byte
824:                               if (retryTimeOut == MCHP24AA512_RETRY_MAX)
000D8E  200640     MOV #0x64, W0
000D90  78009E     MOV [W14], W1
000D92  508F80     SUB W1, W0, [W15]
000D94  320007     BRA Z, 0xDA4
825:                                   break;
000DA4  000000     NOP
826:                               else
827:                                   retryTimeOut++;
000D96  E80F1E     INC [W14], [W14]
828:                           }
829:                       }
830:               
831:                       // exit if the last transaction failed
832:                       if (status == I2C1_MESSAGE_FAIL) {
000DA6  90004E     MOV [W14+8], W0
000DA8  E00000     CP0 W0
000DAA  3A0002     BRA NZ, 0xDB0
833:                           return (0);
000DAC  EB4000     CLR.B W0
000DAE  37000E     BRA 0xDCC
834:                           break;
835:                       }
836:               
837:                       pD++;
000DB0  90003E     MOV [W14+6], W0
000DB2  E80000     INC W0, W0
000DB4  980730     MOV W0, [W14+6]
838:                       address++;
000DB6  90007E     MOV [W14+14], W0
000DB8  E80000     INC W0, W0
000DBA  980770     MOV W0, [W14+14]
839:               
840:                   }
841:                   return (1);
000DCA  B3C010     MOV.B #0x1, W0
842:               
843:               }
000DCC  FA8000     ULNK
000DCE  060000     RETURN
844:               
845:               void i2c_start(void) {
000DD0  FA0002     LNK #0x2
846:                   int x = 0;
000DD2  EB0000     CLR W0
000DD4  780F00     MOV W0, [W14]
847:                   I2C1CONbits.ACKDT = 0; //Reset any previous Ack
000DD6  A9A206     BCLR I2C1CON, #5
848:                   __delay_us(10)
000DD8  200A00     MOV #0xA0, W0
000DDA  200001     MOV #0x0, W1
000DDC  07082C     RCALL ___delay32
849:               
850:                   I2C1CONbits.SEN = 1; //Initiate Start condition
000DDE  A80206     BSET I2C1CON, #0
851:                   Nop();
000DE0  000000     NOP
852:               
853:                   //the hardware will automatically clear Start Bit
854:                   //wait for automatic clear before proceding
855:                   while (I2C1CONbits.SEN) {
000DE2  370007     BRA 0xDF2
000DF2  801030     MOV I2C1CON, W0
000DF4  600061     AND W0, #0x1, W0
000DF6  E00000     CP0 W0
000DF8  3AFFF5     BRA NZ, 0xDE4
000DFA  370001     BRA 0xDFE
856:                       __delay_us(1);
000DE4  200100     MOV #0x10, W0
000DE6  200001     MOV #0x0, W1
000DE8  070826     RCALL ___delay32
857:                       x++;
000DEA  E80F1E     INC [W14], [W14]
858:                       if (x > 20)
000DEC  78001E     MOV [W14], W0
000DEE  500FF4     SUB W0, #0x14, [W15]
000DF0  3C0005     BRA GT, 0xDFC
859:                           break;
000DFC  000000     NOP
860:                   }
861:                   __delay_us(2);
000DFE  200200     MOV #0x20, W0
000E00  200001     MOV #0x0, W1
000E02  070819     RCALL ___delay32
862:               }
000E04  FA8000     ULNK
000E06  060000     RETURN
863:               
864:               void i2c_stop(void){
000E08  FA0002     LNK #0x2
865:                   int x = 0;
000E0A  EB0000     CLR W0
000E0C  780F00     MOV W0, [W14]
866:                   I2C1CONbits.ACKDT = 0; //Reset any previous Ack
000E0E  A9A206     BCLR I2C1CON, #5
867:                   __delay_us(10)
000E10  200A00     MOV #0xA0, W0
000E12  200001     MOV #0x0, W1
000E14  070810     RCALL ___delay32
868:               
869:                   I2C1CONbits.PEN = 1; // Stop Condition Enable bit
000E16  A84206     BSET I2C1CON, #2
870:                   Nop();
000E18  000000     NOP
871:               
872:                   //the hardware will automatically clear stop Bit
873:                   //wait for automatic clear before proceding
874:                   while (I2C1CONbits.PEN) {
000E1A  37000A     BRA 0xE30
000E30  801030     MOV I2C1CON, W0
000E32  600064     AND W0, #0x4, W0
000E34  E00000     CP0 W0
000E36  3AFFF2     BRA NZ, 0xE1C
000E38  370001     BRA 0xE3C
875:                       __delay_us(1);
000E1C  200100     MOV #0x10, W0
000E1E  200001     MOV #0x0, W1
000E20  07080A     RCALL ___delay32
876:                       x++;
000E22  E80F1E     INC [W14], [W14]
877:                       UART1PutChar(x);
000E24  78001E     MOV [W14], W0
000E26  784000     MOV.B W0, W0
000E28  07076A     RCALL UART1PutChar
878:                       if (x > 20)
000E2A  78001E     MOV [W14], W0
000E2C  500FF4     SUB W0, #0x14, [W15]
000E2E  3C0005     BRA GT, 0xE3A
879:                           break;
000E3A  000000     NOP
880:                   }
881:                //   I2C1CONbits.PEN = 0; // Stop Condition Enable bit
882:                   __delay_us(2);
000E3C  200200     MOV #0x20, W0
000E3E  200001     MOV #0x0, W1
000E40  0707FA     RCALL ___delay32
883:               }
000E42  FA8000     ULNK
000E44  060000     RETURN
884:               
885:               void i2c_repeatedStart(void){
000E46  FA0002     LNK #0x2
886:                       int x = 0;
000E48  EB0000     CLR W0
000E4A  780F00     MOV W0, [W14]
887:                   I2C1CONbits.ACKDT = 0; //Reset any previous Ack
000E4C  A9A206     BCLR I2C1CON, #5
888:                   __delay_us(10)
000E4E  200A00     MOV #0xA0, W0
000E50  200001     MOV #0x0, W1
000E52  0707F1     RCALL ___delay32
889:               
890:                   I2C1CONbits.RSEN = 1; //Initiate Start condition
000E54  A82206     BSET I2C1CON, #1
891:                   Nop();
000E56  000000     NOP
892:               
893:                   //the hardware will automatically clear Start Bit
894:                   //wait for automatic clear before proceding
895:                   while (I2C1CONbits.RSEN) {
000E58  370007     BRA 0xE68
000E68  801030     MOV I2C1CON, W0
000E6A  600062     AND W0, #0x2, W0
000E6C  E00000     CP0 W0
000E6E  3AFFF5     BRA NZ, 0xE5A
000E70  370001     BRA 0xE74
896:                       __delay_us(1);
000E5A  200100     MOV #0x10, W0
000E5C  200001     MOV #0x0, W1
000E5E  0707EB     RCALL ___delay32
897:                       x++;
000E60  E80F1E     INC [W14], [W14]
898:                       if (x > 20)
000E62  78001E     MOV [W14], W0
000E64  500FF4     SUB W0, #0x14, [W15]
000E66  3C0005     BRA GT, 0xE72
899:                           break;
000E72  000000     NOP
900:                   }
901:                   __delay_us(2);
000E74  200200     MOV #0x20, W0
000E76  200001     MOV #0x0, W1
000E78  0707DE     RCALL ___delay32
902:               }
000E7A  FA8000     ULNK
000E7C  060000     RETURN
903:               void i2c_restart(void)
904:               {
000E7E  FA0002     LNK #0x2
905:                  int x = 0;
000E80  EB0000     CLR W0
000E82  780F00     MOV W0, [W14]
906:               
907:                  I2C1CONbits.RSEN = 1;	//Initiate restart condition
000E84  A82206     BSET I2C1CON, #1
908:                  Nop();
000E86  000000     NOP
909:                   
910:                  //the hardware will automatically clear restart bit
911:                  //wait for automatic clear before proceding
912:                  while (I2C1CONbits.RSEN)
000E88  370007     BRA 0xE98
000E98  801030     MOV I2C1CON, W0
000E9A  600062     AND W0, #0x2, W0
000E9C  E00000     CP0 W0
000E9E  3AFFF5     BRA NZ, 0xE8A
000EA0  370001     BRA 0xEA4
913:                  {
914:                   __delay_us(1);
000E8A  200100     MOV #0x10, W0
000E8C  200001     MOV #0x0, W1
000E8E  0707D3     RCALL ___delay32
915:                     x++;
000E90  E80F1E     INC [W14], [W14]
916:                     if (x > 20)	break;
000E92  78001E     MOV [W14], W0
000E94  500FF4     SUB W0, #0x14, [W15]
000E96  3C0005     BRA GT, 0xEA2
000EA2  000000     NOP
917:                  }
918:                   
919:                  __delay_us(2);
000EA4  200200     MOV #0x20, W0
000EA6  200001     MOV #0x0, W1
000EA8  0707C6     RCALL ___delay32
920:               }
000EAA  FA8000     ULNK
000EAC  060000     RETURN
921:               //Resets the I2C bus to Idle
922:                void reset_i2c_bus(void)
923:               {
000EAE  FA0002     LNK #0x2
924:                  int x = 0;
000EB0  EB0000     CLR W0
000EB2  780F00     MOV W0, [W14]
925:               
926:                  //initiate stop bit
927:                  I2C1CONbits.PEN = 1;
000EB4  A84206     BSET I2C1CON, #2
928:               
929:                  //wait for hardware clear of stop bit
930:                  while (I2C1CONbits.PEN)
000EB6  370007     BRA 0xEC6
000EC6  801030     MOV I2C1CON, W0
000EC8  600064     AND W0, #0x4, W0
000ECA  E00000     CP0 W0
000ECC  3AFFF5     BRA NZ, 0xEB8
000ECE  370001     BRA 0xED2
931:                  {
932:                    __delay_us(2);
000EB8  200200     MOV #0x20, W0
000EBA  200001     MOV #0x0, W1
000EBC  0707BC     RCALL ___delay32
933:                     x ++;
000EBE  E80F1E     INC [W14], [W14]
934:                     if (x > 20) break;
000EC0  78001E     MOV [W14], W0
000EC2  500FF4     SUB W0, #0x14, [W15]
000EC4  3C0005     BRA GT, 0xED0
000ED0  000000     NOP
935:                  }
936:                  I2C1CONbits.RCEN = 0;
000ED2  A96206     BCLR I2C1CON, #3
937:                  IFS1bits.MI2C1IF = 0; // Clear Interrupt
000ED4  A92086     BCLR IFS1, #1
938:                  I2C1STATbits.IWCOL = 0;
000ED6  A9E208     BCLR I2C1STAT, #7
939:                  I2C1STATbits.BCL = 0;
000ED8  A94209     BCLR 0x209, #2
940:                 __delay_us(10);
000EDA  200A00     MOV #0xA0, W0
000EDC  200001     MOV #0x0, W1
000EDE  0707AB     RCALL ___delay32
941:               }
000EE0  FA8000     ULNK
000EE2  060000     RETURN
942:               
943:               //basic I2C byte send
944:               char send_i2c_byte(int data)
945:               {
000EE4  FA0004     LNK #0x4
000EE6  980710     MOV W0, [W14+2]
946:                  int i;
947:               
948:                  while (I2C1STATbits.TBF) { }
000EE8  000000     NOP
000EEA  801040     MOV I2C1STAT, W0
000EEC  600061     AND W0, #0x1, W0
000EEE  E00000     CP0 W0
000EF0  3AFFFC     BRA NZ, 0xEEA
949:                  IFS1bits.MI2C1IF = 0; // Clear Interrupt
000EF2  A92086     BCLR IFS1, #1
950:                  I2C1TRN = data; // load the outgoing data byte
000EF4  90001E     MOV [W14+2], W0
000EF6  881010     MOV W0, I2C1TRN
951:               
952:                  // wait for transmission
953:                  for (i=0; i<500; i++)
000EF8  EB0000     CLR W0
000EFA  780F00     MOV W0, [W14]
000EFC  370009     BRA 0xF10
000F0E  E80F1E     INC [W14], [W14]
000F10  201F30     MOV #0x1F3, W0
000F12  78009E     MOV [W14], W1
000F14  508F80     SUB W1, W0, [W15]
000F16  34FFF3     BRA LE, 0xEFE
000F18  370001     BRA 0xF1C
954:                  {
955:                     if (!I2C1STATbits.TRSTAT) break;
000EFE  801041     MOV I2C1STAT, W1
000F00  240000     MOV #0x4000, W0
000F02  608000     AND W1, W0, W0
000F04  E00000     CP0 W0
000F06  320009     BRA Z, 0xF1A
000F1A  000000     NOP
956:                     __delay_us(1);
000F08  200100     MOV #0x10, W0
000F0A  200001     MOV #0x0, W1
000F0C  070794     RCALL ___delay32
957:               
958:                     }
959:                     if (i == 500) {
000F1C  201F40     MOV #0x1F4, W0
000F1E  78009E     MOV [W14], W1
000F20  508F80     SUB W1, W0, [W15]
000F22  3A0002     BRA NZ, 0xF28
960:                     return(1);
000F24  B3C010     MOV.B #0x1, W0
000F26  37000E     BRA 0xF44
961:                  }
962:               
963:                  // Check for NO_ACK from slave, abort if not found
964:                  if (I2C1STATbits.ACKSTAT ==1)
000F28  801041     MOV I2C1STAT, W1
000F2A  280000     MOV #0x8000, W0
000F2C  608000     AND W1, W0, W0
000F2E  E00000     CP0 W0
000F30  320005     BRA Z, 0xF3C
965:                  {
966:                     UART1PutStr("no ack-reset");
000F32  287D00     MOV #0x87D0, W0
000F34  0706F0     RCALL UART1PutStr
967:                     reset_i2c_bus();
000F36  07FFBB     RCALL reset_i2c_bus
968:                     return(1);
000F38  B3C010     MOV.B #0x1, W0
000F3A  370004     BRA 0xF44
969:                  }
970:                  
971:                 __delay_us(2);
000F3C  200200     MOV #0x20, W0
000F3E  200001     MOV #0x0, W1
000F40  07077A     RCALL ___delay32
972:                  return(0);
000F42  EB4000     CLR.B W0
973:               }
000F44  FA8000     ULNK
000F46  060000     RETURN
974:               
975:               
976:               //function reads data, returns the read data, no ack
977:               char i2c_read(void)
978:               {
000F48  FA0004     LNK #0x4
979:                  int i = 0;
000F4A  EB0000     CLR W0
000F4C  780F00     MOV W0, [W14]
980:                  char data = 0;
000F4E  EB4000     CLR.B W0
000F50  984720     MOV.B W0, [W14+2]
981:               
982:                  //set I2C module to receive
983:                  I2C1CONbits.RCEN = 1;
000F52  A86206     BSET I2C1CON, #3
984:               
985:                  //if no response, break
986:                  while (!I2C1STATbits.RBF)
000F54  370005     BRA 0xF60
000F60  801040     MOV I2C1STAT, W0
000F62  600062     AND W0, #0x2, W0
000F64  E00000     CP0 W0
000F66  32FFF7     BRA Z, 0xF56
000F68  370001     BRA 0xF6C
987:                  {
988:                     i ++;
000F56  E80F1E     INC [W14], [W14]
989:                     if (i > 2000) break;
000F58  207D00     MOV #0x7D0, W0
000F5A  78009E     MOV [W14], W1
000F5C  508F80     SUB W1, W0, [W15]
000F5E  3C0005     BRA GT, 0xF6A
000F6A  000000     NOP
990:                  }
991:               
992:                  //get data from I2CRCV register
993:                  data = I2C1RCV;
000F6C  801000     MOV I2C1RCV, W0
000F6E  984720     MOV.B W0, [W14+2]
994:               
995:                  //return data
996:                  return data;
000F70  90402E     MOV.B [W14+2], W0
997:               }
000F72  FA8000     ULNK
000F74  060000     RETURN
998:               
999:               //function reads data, returns the read data, with ack
1000:              char i2c_read_ack(void)	//does not reset bus!!!
1001:              {
000F76  FA0004     LNK #0x4
1002:                 int i = 0;
000F78  EB0000     CLR W0
000F7A  780F00     MOV W0, [W14]
1003:                 char data = 0;
000F7C  EB4000     CLR.B W0
000F7E  984720     MOV.B W0, [W14+2]
1004:                
1005:                 //set I2C module to receive
1006:                 I2C1CONbits.RCEN = 1;
000F80  A86206     BSET I2C1CON, #3
1007:              
1008:                 //if no response, break
1009:                 while (!I2C1STATbits.RBF)
000F82  370005     BRA 0xF8E
000F8E  801040     MOV I2C1STAT, W0
000F90  600062     AND W0, #0x2, W0
000F92  E00000     CP0 W0
000F94  32FFF7     BRA Z, 0xF84
000F96  370001     BRA 0xF9A
1010:                 {
1011:                    i++;
000F84  E80F1E     INC [W14], [W14]
1012:                    if (i > 2000) break;
000F86  207D00     MOV #0x7D0, W0
000F88  78009E     MOV [W14], W1
000F8A  508F80     SUB W1, W0, [W15]
000F8C  3C0005     BRA GT, 0xF98
000F98  000000     NOP
1013:                   // UART1PutChar('R');
1014:                 }
1015:                 i=0;
000F9A  EB0000     CLR W0
000F9C  780F00     MOV W0, [W14]
1016:                 //get data from I2CRCV register
1017:                 data = I2C1RCV;
000F9E  801000     MOV I2C1RCV, W0
000FA0  984720     MOV.B W0, [W14+2]
1018:                
1019:                 __delay_us(2);  
000FA2  200200     MOV #0x20, W0
000FA4  200001     MOV #0x0, W1
000FA6  070747     RCALL ___delay32
1020:                 
1021:                 //i2c_ack();
1022:                 __delay_us(2);
000FA8  200200     MOV #0x20, W0
000FAA  200001     MOV #0x0, W1
000FAC  070744     RCALL ___delay32
1023:              
1024:                 return data;
000FAE  90402E     MOV.B [W14+2], W0
1025:                 
1026:              }
000FB0  FA8000     ULNK
000FB2  060000     RETURN
1027:              void i2c_mIdleI2C1(void){
000FB4  FA0000     LNK #0x0
1028:                  
1029:              while((I2C1CON&0x001F)!=0){UART1PutChar('d');}
000FB6  370002     BRA 0xFBC
000FB8  B3C640     MOV.B #0x64, W0
000FBA  0706A1     RCALL UART1PutChar
000FBC  801030     MOV I2C1CON, W0
000FBE  60007F     AND W0, #0x1F, W0
000FC0  E00000     CP0 W0
000FC2  3AFFFA     BRA NZ, 0xFB8
1030:              //Wait for Acken, Rcen, Pen, Rsen and Sen to clear
1031:              
1032:              
1033:              }
000FC4  FA8000     ULNK
000FC6  060000     RETURN
1034:              void i2c_ack(void){
000FC8  FA0000     LNK #0x0
1035:                   I2C1CONbits.ACKDT=0 ;
000FCA  A9A206     BCLR I2C1CON, #5
1036:                           Nop();
000FCC  000000     NOP
1037:                           //I2C1CONbits.ACKEN=0;
1038:                           I2C1CONbits.RCEN=0;
000FCE  A96206     BCLR I2C1CON, #3
1039:                           I2C1CONbits.PEN=0;
000FD0  A94206     BCLR I2C1CON, #2
1040:                           I2C1CONbits.RSEN=0;
000FD2  A92206     BCLR I2C1CON, #1
1041:                           I2C1CONbits.SEN=0;
000FD4  A90206     BCLR I2C1CON, #0
1042:                    //__delay_us(1);       
1043:                     I2C1CONbits.ACKEN = 1;
000FD6  A88206     BSET I2C1CON, #4
1044:                 while (I2C1CONbits.ACKEN==1){UART1PutChar('A');};
000FD8  370002     BRA 0xFDE
000FDA  B3C410     MOV.B #0x41, W0
000FDC  070690     RCALL UART1PutChar
000FDE  801030     MOV I2C1CON, W0
000FE0  600070     AND W0, #0x10, W0
000FE2  E00000     CP0 W0
000FE4  3AFFFA     BRA NZ, 0xFDA
1045:              }
000FE6  FA8000     ULNK
000FE8  060000     RETURN
1046:              
1047:              void i2c_nack(void){
000FEA  FA0000     LNK #0x0
1048:                   I2C1CONbits.ACKDT=1 ;
000FEC  A8A206     BSET I2C1CON, #5
1049:                           Nop();
000FEE  000000     NOP
1050:                           //I2C1CONbits.ACKEN=0;
1051:                           I2C1CONbits.RCEN=0;
000FF0  A96206     BCLR I2C1CON, #3
1052:                           I2C1CONbits.PEN=0;
000FF2  A94206     BCLR I2C1CON, #2
1053:                           I2C1CONbits.RSEN=0;
000FF4  A92206     BCLR I2C1CON, #1
1054:                           I2C1CONbits.SEN=0;
000FF6  A90206     BCLR I2C1CON, #0
1055:                    //__delay_us(1);       
1056:                     I2C1CONbits.ACKEN = 1;
000FF8  A88206     BSET I2C1CON, #4
1057:                 while (I2C1CONbits.ACKEN==1){UART1PutChar('A');};
000FFA  370002     BRA 0x1000
000FFC  B3C410     MOV.B #0x41, W0
000FFE  07067F     RCALL UART1PutChar
001000  801030     MOV I2C1CON, W0
001002  600070     AND W0, #0x10, W0
001004  E00000     CP0 W0
001006  3AFFFA     BRA NZ, 0xFFC
1058:              }
001008  FA8000     ULNK
00100A  060000     RETURN
1059:              void si7020test(){
00100C  FA0000     LNK #0x0
1060:                  //i2c_start();  
1061:                  
1062:                  
1063:                  send_i2c_byte(0x81);
00100E  200810     MOV #0x81, W0
001010  07FF69     RCALL send_i2c_byte
1064:                  
1065:                  send_i2c_byte(0xE3);
001012  200E30     MOV #0xE3, W0
001014  07FF67     RCALL send_i2c_byte
1066:                  
1067:                 // char cc=i2c_read_ack();
1068:                  
1069:               
1070:                  
1071:                  
1072:              }
001016  FA8000     ULNK
001018  060000     RETURN
1073:              int calcuateTemperature(uint16_v code)
1074:              {
00101A  FA0004     LNK #0x4
00101C  980710     MOV W0, [W14+2]
1075:                 
1076:                 
1077:                 uint16_t temp;
1078:                  // Calculate the temperature using the formula from the datasheet
1079:                  
1080:                  //temp = ((((int)17572 * code.w) + 0x8000) >> 16) - 4685;
1081:                  //temp= temp/100;
1082:                 
1083:                  temp=((157.52*code.w)/65536)-46.85;
00101E  90001E     MOV [W14+2], W0
001020  EB0080     CLR W1
001022  07FA14     RCALL ___floatunsisf
001024  2851F2     MOV #0x851F, W2
001026  2431D3     MOV #0x431D, W3
001028  07FA66     RCALL ___mulsf3
00102A  200002     MOV #0x0, W2
00102C  247803     MOV #0x4780, W3
00102E  07F9B1     RCALL ___divsf3
001030  266662     MOV #0x6666, W2
001032  2423B3     MOV #0x423B, W3
001034  07F950     RCALL ___subsf3
001036  07F9EF     RCALL ___fixunssfsi
001038  780F00     MOV W0, [W14]
1084:                  // Return value is to be scaled by 10
1085:                  //*tempCx10 = (temp + 5) / 10;
1086:                  tempo =temp;
00103A  78009E     MOV [W14], W1
00103C  884281     MOV W1, tempo
1087:                  return temp;
00103E  78001E     MOV [W14], W0
1088:              }
001040  FA8000     ULNK
001042  060000     RETURN
001044  FA0006     LNK #0x6
1089:               
---  C:/Users/IdeaPad/MPLABXProjects/picTest.X/hwConfig.c  ----------------------------------------------
1:                 #include "extralDefines.h"
2:                 #include "hwConfig.h"
3:                 #include "spiDriver.h"
4:                 
5:                 /******************************************************************************/
6:                 // Hardware Init:
7:                 // Init peripherals
8:                 // Configure pins
9:                 /******************************************************************************/
10:                void hwInit(void)
11:                {
001B68  FA0000     LNK #0x0
12:                    /***************/
13:                    /* PPS mapping */
14:                    /***************/
15:                    asm volatile("disi	#6");
001B6A  FC0006     DISI #0x6
16:                    asm volatile("MOV   #OSCCON, w1");
001B6C  207421     MOV #0x742, W1
17:                    asm volatile("MOV   #0x46,   w2");
001B6E  200462     MOV #0x46, W2
18:                    asm volatile("MOV   #0x57,   w3");
001B70  200573     MOV #0x57, W3
19:                    asm volatile("MOV.b w2,    [w1]");
001B72  784882     MOV.B W2, [W1]
20:                    asm volatile("MOV.b w3,    [w1]");
001B74  784883     MOV.B W3, [W1]
21:                    asm volatile("BCLR  OSCCON,  #6");
001B76  A9C742     BCLR OSCCON, #6
22:                
23:                    RPOR12bits.RP24R = 3;       // U1 Tx   
001B78  8036C1     MOV RPOR12, W1
001B7A  2FFC00     MOV #0xFFC0, W0
001B7C  608000     AND W1, W0, W0
001B7E  B30030     IOR #0x3, W0
001B80  8836C0     MOV W0, RPOR12
24:                    //me
25:                    RPINR18bits.U1RXR = 20;     // U1 Rx
001B82  803521     MOV RPINR18, W1
001B84  2FFC00     MOV #0xFFC0, W0
001B86  608000     AND W1, W0, W0
001B88  B30140     IOR #0x14, W0
001B8A  883520     MOV W0, RPINR18
26:                    
27:                    
28:                    // RPOR11bits.RP23R = 3;       // U1 Tx    
29:                     //vova
30:                    // RPINR18bits.U1RXR = 24;     // U1 Rx
31:                    
32:                    RPOR3bits.RP6R = 5;         // U2 Tx
001B8C  803631     MOV RPOR3, W1
001B8E  2FFC00     MOV #0xFFC0, W0
001B90  608000     AND W1, W0, W0
001B92  B30050     IOR #0x5, W0
001B94  883630     MOV W0, RPOR3
33:                    RPINR19bits.U2RXR = 7;      // U2 Rx
001B96  803531     MOV RPINR19, W1
001B98  2FFC00     MOV #0xFFC0, W0
001B9A  608000     AND W1, W0, W0
001B9C  B30070     IOR #0x7, W0
001B9E  883530     MOV W0, RPINR19
34:                    RPOR10bits.RP21R = 28;      // U3 Tx
001BA0  8036A1     MOV RPOR10, W1
001BA2  2C0FF0     MOV #0xC0FF, W0
001BA4  608080     AND W1, W0, W1
001BA6  21C000     MOV #0x1C00, W0
001BA8  700001     IOR W0, W1, W0
001BAA  8836A0     MOV W0, RPOR10
35:                    RPINR17bits.U3RXR = 26;     // U3 Rx
001BAC  803511     MOV RPINR17, W1
001BAE  2C0FF0     MOV #0xC0FF, W0
001BB0  608080     AND W1, W0, W1
001BB2  21A000     MOV #0x1A00, W0
001BB4  700001     IOR W0, W1, W0
001BB6  883510     MOV W0, RPINR17
36:                    
37:                    
38:                    RPINR20bits.SDI1R = 17;     // SPI1 MISO
001BB8  803541     MOV RPINR20, W1
001BBA  2FFC00     MOV #0xFFC0, W0
001BBC  608000     AND W1, W0, W0
001BBE  B30110     IOR #0x11, W0
001BC0  883540     MOV W0, RPINR20
39:                    
40:                    RPOR5bits.RP10R =7;        // SPI1 MOSI new
001BC2  803651     MOV RPOR5, W1
001BC4  2FFC00     MOV #0xFFC0, W0
001BC6  608000     AND W1, W0, W0
001BC8  B30070     IOR #0x7, W0
001BCA  883650     MOV W0, RPOR5
41:                    
42:                    RPOR8bits.RP17R = 8;       // SPI1 CLK new
001BCC  803681     MOV RPOR8, W1
001BCE  2C0FF0     MOV #0xC0FF, W0
001BD0  608080     AND W1, W0, W1
001BD2  208000     MOV #0x800, W0
001BD4  700001     IOR W0, W1, W0
001BD6  883680     MOV W0, RPOR8
43:                    
44:                    
45:                    
46:                   //RPOR5bits.RP10R5= ; 
47:                    
48:                    //RPINR0bits.INT1R = 7;       // Ext Int 1
49:                   // RPINR22bits.SDI2R = 24;     // SPI2 MISO
50:                    //RPOR11bits.RP23R = 10;      // SPI2 MOSI
51:                    //RPOR11bits.RP22R = 11;      // SPI2 CLK
52:                    
53:                   // TRISF=0x0000;
54:                    //AN14/RP14/SEG8/CTED5/CTPLS/PMA1/CN32/RB14
55:                    
56:                
57:                    asm volatile("disi	#6");
001BD8  FC0006     DISI #0x6
58:                    asm volatile("MOV   #OSCCON, w1");
001BDA  207421     MOV #0x742, W1
59:                    asm volatile("MOV   #0x46,   w2");
001BDC  200462     MOV #0x46, W2
60:                    asm volatile("MOV   #0x57,   w3");
001BDE  200573     MOV #0x57, W3
61:                    asm volatile("MOV.b w2,    [w1]");
001BE0  784882     MOV.B W2, [W1]
62:                    asm volatile("MOV.b w3,    [w1]");
001BE2  784883     MOV.B W3, [W1]
63:                    asm volatile("BSET  OSCCON,  #6");
001BE4  A8C742     BSET OSCCON, #6
64:                
65:                    /******************************/
66:                    /* Disable Unused peripherals */
67:                    /******************************/
68:                //    PMD1 = 0xC080;
69:                //    PMD2 = 0xFFFF;
70:                //    PMD3 = 0xFDF7;
71:                //    PMD4 = 0xFFFD;
72:                //    PMD6 = 0xFFFF;
73:                //    PMD7 = 0xFFFF;
74:                    
75:                    /***********/
76:                    /* IO init */
77:                    /***********/
78:                    TRISB = 0x0000;
001BE6  EF22C8     CLR TRISB
79:                    PORTB = 0x0000;
001BE8  EF22CA     CLR PORTB
80:                    ANSB  = 0x0000;
001BEA  EF24E2     CLR ANSB
81:                
82:                    TRISC = 0x2000;
001BEC  220000     MOV #0x2000, W0
001BEE  881680     MOV W0, TRISC
83:                    PORTC = 0x2000;
001BF0  220000     MOV #0x2000, W0
001BF2  881690     MOV W0, PORTC
84:                
85:                    TRISD = 0x0012;
001BF4  200120     MOV #0x12, W0
001BF6  8816C0     MOV W0, TRISD
86:                    PORTD = 0x00B2;
001BF8  200B20     MOV #0xB2, W0
001BFA  8816D0     MOV W0, PORTD
87:                    ANSD  = 0x0000;
001BFC  EF24E6     CLR ANSD
88:                
89:                    TRISE = 0x0000;
001BFE  EF22E0     CLR TRISE
90:                    PORTE = 0x0000;
001C00  EF22E2     CLR PORTE
91:                    ANSE  = 0x0000;
001C02  EF24E8     CLR ANSE
92:                
93:                    TRISF = 0x0000;
001C04  EF22E8     CLR TRISF
94:                    PORTF = 0x0000;
001C06  EF22EA     CLR PORTF
95:                   
96:                
97:                    
98:                    
99:                    TRISG = 0x0000;
001C08  EF22F0     CLR TRISG
100:                   PORTG = 0x0000;
001C0A  EF22F2     CLR PORTG
101:                   ANSG  = 0x0000;
001C0C  EF24EC     CLR ANSG
102:               
103:                //   DHT_TRS = 0; //Configure RD0 as output
104:                   //DHT = 1; //RD0 sends 0 to the sensor
105:               }
001C0E  FA8000     ULNK
001C10  060000     RETURN
106:               
107:               
108:               void enableRTCC(void){
001C12  FA0000     LNK #0x0
109:                   // unlock RTCC
110:               asm volatile ("disi #5");
001C14  FC0005     DISI #0x5
111:               asm volatile ("mov #0x55,w7");
001C16  200557     MOV #0x55, W7
112:               asm volatile ("mov w7,_NVMKEY");
001C18  883B37     MOV W7, NVMKEY
113:               asm volatile ("mov #0xAA, w8");
001C1A  200AA8     MOV #0xAA, W8
114:               asm volatile ("mov w8, _NVMKEY");
001C1C  883B38     MOV W8, NVMKEY
115:               asm volatile ("bset _RCFGCAL,#13");
001C1E  A8A627     BSET 0x627, #5
116:               asm volatile ("nop");
001C20  000000     NOP
117:               asm volatile ("nop");
001C22  000000     NOP
118:               
119:               //_RTCEN = 0; // disable the module
120:               
121:               //_RTCPTR = 3; // start the loading sequence
122:               //RTCVAL = 0x2010; // YEAR
123:               //RTCVAL = 0x1216; // MONTH-1/DAY-1
124:               //RTCVAL = 0x0403; // WEEKDAY/HOURS
125:               //RTCVAL = 0x0130; // MINUTES/SECONDS
126:               
127:               
128:               }
001C24  FA8000     ULNK
001C26  060000     RETURN
129:               
130:               /******************************************************************************/
131:               //
132:               /******************************************************************************/
133:               void disableHw(void)
134:               {
001C28  FA0000     LNK #0x0
135:                   INT0_DISABLE;
001C2A  A90094     BCLR IEC0, #0
136:                   INT0_CLEAR;
001C2C  A90084     BCLR IFS0, #0
137:                   INT1_DISABLE;
001C2E  A98096     BCLR IEC1, #4
138:                   INT1_CLEAR;
001C30  A98086     BCLR IFS1, #4
139:                   TIMER1_DISABLE;
001C32  A9E105     BCLR 0x105, #7
140:                   TIMER1_INTERRUPT_CLEAR;
001C34  A96084     BCLR IFS0, #3
141:                   TIMER2_DISABLE;
001C36  A9E111     BCLR 0x111, #7
142:                   TIMER2_INTERRUPT_CLEAR;
001C38  A9E084     BCLR IFS0, #7
143:                   ADC_DISABLE;
001C3A  A9E341     BCLR 0x341, #7
144:                   ADC_INTERRUPT_CLEAR;
001C3C  A9A085     BCLR 0x85, #5
145:               }
001C3E  FA8000     ULNK
001C40  060000     RETURN
001C42  FA0000     LNK #0x0
1:                 /*
2:                  * File:   dht.c
3:                  * Author: IdeaPad
4:                  *
5:                  * Created on 2. marts 2016, 11:12
6:                  */
7:                 
8:                 
9:                 #include "xc.h"
10:                #include "extralDefines.h"
11:                #define FCY     16000000ULL //TO DO
12:                #include <libpic30.h>
13:                
14:                
15:                
16:                
17:                unsigned char Check, T_byte1, T_byte2,
18:                RH_byte1, RH_byte2, Ch;
19:                unsigned Temp, RH, Sum;
20:                
21:                void StartSignal() {
001C42  FA0000     LNK #0x0
22:                
23:                    DHT_TRS = 0; //Configure RD0 as output
001C44  A962E8     BCLR TRISF, #3
24:                    // DHT=1 ;
25:                    //__delay_ms(250);
26:                    DHT = 0; //RD0 sends 0 to the sensor
001C46  A962EA     BCLR PORTF, #3
27:                    __delay_ms(20);
001C48  2E2000     MOV #0xE200, W0
001C4A  200041     MOV #0x4, W1
001C4C  0700F4     RCALL ___delay32
28:                    DHT = 1; //RD0 sends 1 to the sensor
001C4E  A862EA     BSET PORTF, #3
29:                
30:                    __delay_us(30);
001C50  201E00     MOV #0x1E0, W0
001C52  200001     MOV #0x0, W1
001C54  0700F0     RCALL ___delay32
31:                    DHT_TRS = 1; //Configure RD0 as input
001C56  A862E8     BSET TRISF, #3
32:                
33:                }
001C58  FA8000     ULNK
001C5A  060000     RETURN
34:                //////////////////////////////
35:                
36:                void CheckResponse() {
001C5C  FA0000     LNK #0x0
37:                    Check = 0;
001C5E  EF686A     CLR.B Check
38:                    __delay_us(50);
001C60  203200     MOV #0x320, W0
001C62  200001     MOV #0x0, W1
001C64  0700E8     RCALL ___delay32
39:                
40:                    if (DHT == 0) {
001C66  801750     MOV PORTF, W0
001C68  600068     AND W0, #0x8, W0
001C6A  E00000     CP0 W0
001C6C  3A000C     BRA NZ, 0x1C86
41:                        __delay_us(80);
001C6E  205000     MOV #0x500, W0
001C70  200001     MOV #0x0, W1
001C72  0700E1     RCALL ___delay32
42:                
43:                
44:                        if (DHT == 1) {
001C74  801750     MOV PORTF, W0
001C76  600068     AND W0, #0x8, W0
001C78  E00000     CP0 W0
001C7A  320005     BRA Z, 0x1C86
45:                            Check = 1;
001C7C  B3C010     MOV.B #0x1, W0
001C7E  B7E86A     MOV.B WREG, Check
46:                            __delay_us(40);
001C80  202800     MOV #0x280, W0
001C82  200001     MOV #0x0, W1
001C84  0700D8     RCALL ___delay32
47:                        }
48:                    }
49:                
50:                }
001C86  FA8000     ULNK
001C88  060000     RETURN
51:                //////////////////////////////
52:                
53:                char ReadData() {
001C8A  FA0002     LNK #0x2
54:                    char i, j;
55:                    for (j = 0; j < 8; j++) {
001C8C  EB4000     CLR.B W0
001C8E  984710     MOV.B W0, [W14+1]
001C90  370024     BRA 0x1CDA
001CD4  90401E     MOV.B [W14+1], W0
001CD6  E84000     INC.B W0, W0
001CD8  984710     MOV.B W0, [W14+1]
001CDA  90401E     MOV.B [W14+1], W0
001CDC  504FE7     SUB.B W0, #0x7, [W15]
001CDE  34FFD9     BRA LE, 0x1C92
56:                        while (!DHT); //Wait until PORTD.F0 goes HIGH
001C92  000000     NOP
001C94  801750     MOV PORTF, W0
001C96  600068     AND W0, #0x8, W0
001C98  E00000     CP0 W0
001C9A  32FFFC     BRA Z, 0x1C94
57:                        __delay_us(30);
001C9C  201E00     MOV #0x1E0, W0
001C9E  200001     MOV #0x0, W1
001CA0  0700CA     RCALL ___delay32
58:                        if (DHT == 0)
001CA2  801750     MOV PORTF, W0
001CA4  600068     AND W0, #0x8, W0
001CA6  E00000     CP0 W0
001CA8  3A0009     BRA NZ, 0x1CBC
59:                            i &= ~(1 << (7 - j)); //Clear bit (7-b)
001CAA  90401E     MOV.B [W14+1], W0
001CAC  FB0000     SE W0, W0
001CAE  100067     SUBR W0, #0x7, W0
001CB0  200011     MOV #0x1, W1
001CB2  DD0800     SL W1, W0, W0
001CB4  784000     MOV.B W0, W0
001CB6  EAC000     COM.B W0, W0
001CB8  604F1E     AND.B W0, [W14], [W14]
001CBA  37000C     BRA 0x1CD4
60:                        else {
61:                            i |= (1 << (7 - j)); //Set bit (7-b)
001CBC  90401E     MOV.B [W14+1], W0
001CBE  FB0000     SE W0, W0
001CC0  100067     SUBR W0, #0x7, W0
001CC2  200011     MOV #0x1, W1
001CC4  DD0800     SL W1, W0, W0
001CC6  784000     MOV.B W0, W0
001CC8  704F1E     IOR.B W0, [W14], [W14]
62:                            while (DHT);
001CCA  000000     NOP
001CCC  801750     MOV PORTF, W0
001CCE  600068     AND W0, #0x8, W0
001CD0  E00000     CP0 W0
001CD2  3AFFFC     BRA NZ, 0x1CCC
63:                        } //Wait until PORTD.F0 goes LOW
64:                    }
65:                    return i;
001CE0  78401E     MOV.B [W14], W0
66:                }
001CE2  FA8000     ULNK
001CE4  060000     RETURN
001CE6  FA0002     LNK #0x2
67:                
---  C:/Users/IdeaPad/MPLABXProjects/picTest.X/SSD1306.c  -----------------------------------------------
1:                 #include "SSD1306.h"
2:                 #include "extralDefines.h"
3:                 #include "spiDriver.h"
4:                 //#include "peripheral/spi.h"
5:                 
6:                 //#include "device/pinconfig.h"
7:                 
8:                 /* Command talbe, page 28 of SSD1306 datasheet ********************************/
9:                 // Fundamental
10:                #define SSD1306_SET_CONTRAST            0x81
11:                #define SSD1306_ENTIRE_DISPLAYALL_ON    0xA4
12:                #define SSD1306_NORM_INV_DISPLAY        0xA6
13:                #define SSD1306_DISPLAY_ON_OFF          0xAE
14:                
15:                // Scrolling
16:                #define SSD1306_HORIZONTAL_SCROLL           0x26
17:                #define SSD1306_VERTICAL_HORIZONTAL_SCROLL  0x29
18:                #define SSD1306_DEACTIVATE_SCROLL           0x2E
19:                #define SSD1306_ACTIVATE_SCROLL             0x2F
20:                #define SSD1306_SET_VERTICAL_SCROLL_AREA    0xA3
21:                
22:                // Address setting
23:                #define SSD1306_SET_LOW_COLUMN          0x00
24:                #define SSD1306_SET_HIGH_COLUMN         0x10
25:                #define SSD1306_SET_MEMORY_MODE         0x20
26:                #define SSD1306_SET_COLUMN_ADDR         0x21
27:                #define SSD1306_SET_PAGE_ADDR           0x22
28:                #define SSD1306_SET_PAGE_START_ADDR     0xB0
29:                
30:                // Hardware configuration (Panel resolution and layout
31:                #define SSD1306_SET_START_LINE          0x40
32:                #define SSD1306_SET_SEGMENT_REMAP       0xA0
33:                #define SSD1306_SET_MULTIPLEX           0xA8
34:                #define SSD1306_COM_SCAN                0xC0
35:                #define SSD1306_SET_DISPLAY_OFFSET      0xD3
36:                #define SSD1306_SET_COM_PINS            0xDA
37:                
38:                // Timing and driving scheme
39:                #define SSD1306_SET_DISPLAY_CLOCK_DIV   0xD5
40:                #define SSD1306_SET_PRECHARGE           0xD9
41:                #define SSD1306_SET_VCOM_DESELECT       0xDB
42:                #define SSD1306_NOP                     0xE3
43:                
44:                // Charge Pump: page 62
45:                #define SSD1306_CHARGE_PUMP             0x8D
46:                
47:                /* Static functions ***********************************************************/
48:                static void ssd1306_sendCMD(uint8_t* cmd, uint8_t cmdSize);
49:                
50:                static void ssd1306_sendCMD(uint8_t* cmd, uint8_t cmdSize)
51:                {
001044  FA0006     LNK #0x6
001046  980710     MOV W0, [W14+2]
001048  984741     MOV.B W1, [W14+4]
52:                    uint8_t i;
53:                
54:                    OLED_DC = 0;
00104A  A9C2CD     BCLR 0x2CD, #6
55:                    OLED_CS = 0;
00104C  A9E2CD     BCLR 0x2CD, #7
56:                
57:                    for (i = 0; i < cmdSize; i++, cmd++)
00104E  EB4000     CLR.B W0
001050  784F00     MOV.B W0, [W14]
001052  370007     BRA 0x1062
00105A  E84F1E     INC.B [W14], [W14]
00105C  90001E     MOV [W14+2], W0
00105E  E80000     INC W0, W0
001060  980710     MOV W0, [W14+2]
001062  90404E     MOV.B [W14+4], W0
001064  78409E     MOV.B [W14], W1
001066  50CF80     SUB.B W1, W0, [W15]
001068  39FFF5     BRA NC, 0x1054
58:                    {
59:                        //spiWrite(*cmd);
60:                      //  PUT SPI WRITE HERE
61:                        spiTransferByte(*cmd);
001054  90001E     MOV [W14+2], W0
001056  784010     MOV.B [W0], W0
001058  07067D     RCALL spiTransferByte
62:                    }
63:                
64:                    Nop();
00106A  000000     NOP
65:                    Nop();
00106C  000000     NOP
66:                    OLED_CS = 1;
00106E  A8E2CD     BSET 0x2CD, #7
67:                }
001070  FA8000     ULNK
001072  060000     RETURN
001074  FA0006     LNK #0x6
001076  980710     MOV W0, [W14+2]
001078  980721     MOV W1, [W14+4]
00107A  A8C2CD     BSET 0x2CD, #6
00107C  A9E2CD     BCLR 0x2CD, #7
00107E  EB0000     CLR W0
001080  780F00     MOV W0, [W14]
001082  370007     BRA 0x1092
001084  90001E     MOV [W14+2], W0
001086  784010     MOV.B [W0], W0
001088  070665     RCALL spiTransferByte
00108A  E80F1E     INC [W14], [W14]
00108C  90001E     MOV [W14+2], W0
00108E  E80000     INC W0, W0
001090  980710     MOV W0, [W14+2]
001092  90002E     MOV [W14+4], W0
001094  78009E     MOV [W14], W1
001096  508F80     SUB W1, W0, [W15]
001098  39FFF5     BRA NC, 0x1084
00109A  000000     NOP
00109C  000000     NOP
00109E  A8E2CD     BSET 0x2CD, #7
0010A0  FA8000     ULNK
0010A2  060000     RETURN
0010A4  FA0004     LNK #0x4
0010A6  984720     MOV.B W0, [W14+2]
0010A8  B3C810     MOV.B #0x81, W0
0010AA  784F00     MOV.B W0, [W14]
0010AC  9040AE     MOV.B [W14+2], W1
0010AE  984711     MOV.B W1, [W14+1]
0010B0  B3C021     MOV.B #0x2, W1
0010B2  78000E     MOV W14, W0
0010B4  07FFC7     RCALL _ssd1306_sendCMD
0010B6  FA8000     ULNK
0010B8  060000     RETURN
0010BA  FA0004     LNK #0x4
0010BC  984720     MOV.B W0, [W14+2]
0010BE  9040AE     MOV.B [W14+2], W1
0010C0  B3CA40     MOV.B #0xA4, W0
0010C2  70C000     IOR.B W1, W0, W0
0010C4  784F00     MOV.B W0, [W14]
0010C6  B3C011     MOV.B #0x1, W1
0010C8  78000E     MOV W14, W0
0010CA  07FFBC     RCALL _ssd1306_sendCMD
0010CC  FA8000     ULNK
0010CE  060000     RETURN
0010D0  FA0004     LNK #0x4
0010D2  984720     MOV.B W0, [W14+2]
0010D4  9040AE     MOV.B [W14+2], W1
0010D6  B3CA60     MOV.B #0xA6, W0
0010D8  70C000     IOR.B W1, W0, W0
0010DA  784F00     MOV.B W0, [W14]
0010DC  B3C011     MOV.B #0x1, W1
0010DE  78000E     MOV W14, W0
0010E0  07FFB1     RCALL _ssd1306_sendCMD
0010E2  FA8000     ULNK
0010E4  060000     RETURN
0010E6  FA0004     LNK #0x4
0010E8  984720     MOV.B W0, [W14+2]
0010EA  9040AE     MOV.B [W14+2], W1
0010EC  B3CAE0     MOV.B #0xAE, W0
0010EE  70C000     IOR.B W1, W0, W0
0010F0  784F00     MOV.B W0, [W14]
0010F2  B3C011     MOV.B #0x1, W1
0010F4  78000E     MOV W14, W0
0010F6  07FFA6     RCALL _ssd1306_sendCMD
0010F8  FA8000     ULNK
0010FA  060000     RETURN
0010FC  FA000C     LNK #0xC
0010FE  984F00     MOV.B W0, [W14+8]
001100  984F11     MOV.B W1, [W14+9]
001102  984F22     MOV.B W2, [W14+10]
001104  984F33     MOV.B W3, [W14+11]
001106  90488E     MOV.B [W14+8], W1
001108  B3C260     MOV.B #0x26, W0
00110A  70C000     IOR.B W1, W0, W0
00110C  784F00     MOV.B W0, [W14]
00110E  EB4000     CLR.B W0
001110  984710     MOV.B W0, [W14+1]
001112  90489E     MOV.B [W14+9], W1
001114  984721     MOV.B W1, [W14+2]
001116  9048AE     MOV.B [W14+10], W1
001118  984731     MOV.B W1, [W14+3]
00111A  9048BE     MOV.B [W14+11], W1
00111C  984741     MOV.B W1, [W14+4]
00111E  EB4000     CLR.B W0
001120  984750     MOV.B W0, [W14+5]
001122  EBC000     SETM.B W0
001124  984760     MOV.B W0, [W14+6]
001126  B3C071     MOV.B #0x7, W1
001128  78000E     MOV W14, W0
00112A  07FF8C     RCALL _ssd1306_sendCMD
00112C  FA8000     ULNK
00112E  060000     RETURN
001130  FA000C     LNK #0xC
001132  984760     MOV.B W0, [W14+6]
001134  984771     MOV.B W1, [W14+7]
001136  984F02     MOV.B W2, [W14+8]
001138  984F13     MOV.B W3, [W14+9]
00113A  984F24     MOV.B W4, [W14+10]
00113C  9040EE     MOV.B [W14+6], W1
00113E  B3C290     MOV.B #0x29, W0
001140  70C000     IOR.B W1, W0, W0
001142  784F00     MOV.B W0, [W14]
001144  EB4000     CLR.B W0
001146  984710     MOV.B W0, [W14+1]
001148  9040FE     MOV.B [W14+7], W1
00114A  984721     MOV.B W1, [W14+2]
00114C  90488E     MOV.B [W14+8], W1
00114E  984731     MOV.B W1, [W14+3]
001150  90489E     MOV.B [W14+9], W1
001152  984741     MOV.B W1, [W14+4]
001154  9048AE     MOV.B [W14+10], W1
001156  984751     MOV.B W1, [W14+5]
001158  B3C071     MOV.B #0x7, W1
00115A  78000E     MOV W14, W0
00115C  07FF73     RCALL _ssd1306_sendCMD
00115E  FA8000     ULNK
001160  060000     RETURN
001162  FA0002     LNK #0x2
001164  B3C2F0     MOV.B #0x2F, W0
001166  784F00     MOV.B W0, [W14]
001168  B3C011     MOV.B #0x1, W1
00116A  78000E     MOV W14, W0
00116C  07FF6B     RCALL _ssd1306_sendCMD
00116E  FA8000     ULNK
001170  060000     RETURN
001172  FA0002     LNK #0x2
001174  B3C2E0     MOV.B #0x2E, W0
001176  784F00     MOV.B W0, [W14]
001178  B3C011     MOV.B #0x1, W1
00117A  78000E     MOV W14, W0
00117C  07FF63     RCALL _ssd1306_sendCMD
00117E  FA8000     ULNK
001180  060000     RETURN
001182  FA0006     LNK #0x6
001184  984740     MOV.B W0, [W14+4]
001186  984751     MOV.B W1, [W14+5]
001188  B3CA30     MOV.B #0xA3, W0
00118A  784F00     MOV.B W0, [W14]
00118C  9040CE     MOV.B [W14+4], W1
00118E  984711     MOV.B W1, [W14+1]
001190  9040DE     MOV.B [W14+5], W1
001192  984721     MOV.B W1, [W14+2]
001194  B3C031     MOV.B #0x3, W1
001196  78000E     MOV W14, W0
001198  07FF55     RCALL _ssd1306_sendCMD
00119A  FA8000     ULNK
00119C  060000     RETURN
00119E  FA0004     LNK #0x4
0011A0  984720     MOV.B W0, [W14+2]
0011A2  90402E     MOV.B [W14+2], W0
0011A4  60406F     AND.B W0, #0xF, W0
0011A6  784F00     MOV.B W0, [W14]
0011A8  B3C011     MOV.B #0x1, W1
0011AA  78000E     MOV W14, W0
0011AC  07FF4B     RCALL _ssd1306_sendCMD
0011AE  FA8000     ULNK
0011B0  060000     RETURN
0011B2  FA0004     LNK #0x4
0011B4  984720     MOV.B W0, [W14+2]
0011B6  90402E     MOV.B [W14+2], W0
0011B8  60406F     AND.B W0, #0xF, W0
0011BA  A04400     BSET.B W0, #4
0011BC  784F00     MOV.B W0, [W14]
0011BE  B3C011     MOV.B #0x1, W1
0011C0  78000E     MOV W14, W0
0011C2  07FF40     RCALL _ssd1306_sendCMD
0011C4  FA8000     ULNK
0011C6  060000     RETURN
0011C8  FA0004     LNK #0x4
0011CA  984720     MOV.B W0, [W14+2]
0011CC  90402E     MOV.B [W14+2], W0
0011CE  604062     AND.B W0, #0x2, W0
0011D0  B3C201     MOV.B #0x20, W1
0011D2  784F01     MOV.B W1, [W14]
0011D4  984710     MOV.B W0, [W14+1]
0011D6  B3C021     MOV.B #0x2, W1
0011D8  78000E     MOV W14, W0
0011DA  07FF34     RCALL _ssd1306_sendCMD
0011DC  FA8000     ULNK
0011DE  060000     RETURN
0011E0  FA0006     LNK #0x6
0011E2  984740     MOV.B W0, [W14+4]
0011E4  984751     MOV.B W1, [W14+5]
0011E6  90404E     MOV.B [W14+4], W0
0011E8  784080     MOV.B W0, W1
0011EA  A17401     BCLR.B W1, #7
0011EC  90405E     MOV.B [W14+5], W0
0011EE  A17400     BCLR.B W0, #7
0011F0  B3C212     MOV.B #0x21, W2
0011F2  784F02     MOV.B W2, [W14]
0011F4  984711     MOV.B W1, [W14+1]
0011F6  984720     MOV.B W0, [W14+2]
0011F8  B3C031     MOV.B #0x3, W1
0011FA  78000E     MOV W14, W0
0011FC  07FF23     RCALL _ssd1306_sendCMD
0011FE  FA8000     ULNK
001200  060000     RETURN
001202  FA0006     LNK #0x6
001204  984740     MOV.B W0, [W14+4]
001206  984751     MOV.B W1, [W14+5]
001208  90404E     MOV.B [W14+4], W0
00120A  6040E7     AND.B W0, #0x7, W1
00120C  90405E     MOV.B [W14+5], W0
00120E  604067     AND.B W0, #0x7, W0
001210  B3C222     MOV.B #0x22, W2
001212  784F02     MOV.B W2, [W14]
001214  984711     MOV.B W1, [W14+1]
001216  984720     MOV.B W0, [W14+2]
001218  B3C031     MOV.B #0x3, W1
00121A  78000E     MOV W14, W0
00121C  07FF13     RCALL _ssd1306_sendCMD
00121E  FA8000     ULNK
001220  060000     RETURN
001222  FA0004     LNK #0x4
001224  984720     MOV.B W0, [W14+2]
001226  9040AE     MOV.B [W14+2], W1
001228  B3CB00     MOV.B #0xB0, W0
00122A  70C000     IOR.B W1, W0, W0
00122C  784F00     MOV.B W0, [W14]
00122E  B3C011     MOV.B #0x1, W1
001230  78000E     MOV W14, W0
001232  07FF08     RCALL _ssd1306_sendCMD
001234  FA8000     ULNK
001236  060000     RETURN
001238  FA0004     LNK #0x4
00123A  984720     MOV.B W0, [W14+2]
00123C  9040AE     MOV.B [W14+2], W1
00123E  B3C400     MOV.B #0x40, W0
001240  70C000     IOR.B W1, W0, W0
001242  784F00     MOV.B W0, [W14]
001244  B3C011     MOV.B #0x1, W1
001246  78000E     MOV W14, W0
001248  07FEFD     RCALL _ssd1306_sendCMD
00124A  FA8000     ULNK
00124C  060000     RETURN
00124E  FA0004     LNK #0x4
001250  984720     MOV.B W0, [W14+2]
001252  9040AE     MOV.B [W14+2], W1
001254  B3CA00     MOV.B #0xA0, W0
001256  70C000     IOR.B W1, W0, W0
001258  784F00     MOV.B W0, [W14]
00125A  B3C011     MOV.B #0x1, W1
00125C  78000E     MOV W14, W0
00125E  07FEF2     RCALL _ssd1306_sendCMD
001260  FA8000     ULNK
001262  060000     RETURN
001264  FA0004     LNK #0x4
001266  984720     MOV.B W0, [W14+2]
001268  90402E     MOV.B [W14+2], W0
00126A  B243F0     AND.B #0x3F, W0
00126C  B3CA81     MOV.B #0xA8, W1
00126E  784F01     MOV.B W1, [W14]
001270  984710     MOV.B W0, [W14+1]
001272  B3C021     MOV.B #0x2, W1
001274  78000E     MOV W14, W0
001276  07FEE6     RCALL _ssd1306_sendCMD
001278  FA8000     ULNK
00127A  060000     RETURN
00127C  FA0004     LNK #0x4
00127E  984720     MOV.B W0, [W14+2]
001280  9040AE     MOV.B [W14+2], W1
001282  B3CC00     MOV.B #0xC0, W0
001284  70C000     IOR.B W1, W0, W0
001286  784F00     MOV.B W0, [W14]
001288  B3C011     MOV.B #0x1, W1
00128A  78000E     MOV W14, W0
00128C  07FEDB     RCALL _ssd1306_sendCMD
00128E  FA8000     ULNK
001290  060000     RETURN
001292  FA0004     LNK #0x4
001294  984720     MOV.B W0, [W14+2]
001296  90402E     MOV.B [W14+2], W0
001298  B243F0     AND.B #0x3F, W0
00129A  B3CD31     MOV.B #0xD3, W1
00129C  784F01     MOV.B W1, [W14]
00129E  984710     MOV.B W0, [W14+1]
0012A0  B3C021     MOV.B #0x2, W1
0012A2  78000E     MOV W14, W0
0012A4  07FECF     RCALL _ssd1306_sendCMD
0012A6  FA8000     ULNK
0012A8  060000     RETURN
0012AA  FA0004     LNK #0x4
0012AC  984720     MOV.B W0, [W14+2]
0012AE  B3CDA0     MOV.B #0xDA, W0
0012B0  784F00     MOV.B W0, [W14]
0012B2  9040AE     MOV.B [W14+2], W1
0012B4  984711     MOV.B W1, [W14+1]
0012B6  B3C021     MOV.B #0x2, W1
0012B8  78000E     MOV W14, W0
0012BA  07FEC4     RCALL _ssd1306_sendCMD
0012BC  FA8000     ULNK
0012BE  060000     RETURN
0012C0  FA0004     LNK #0x4
0012C2  984720     MOV.B W0, [W14+2]
0012C4  984731     MOV.B W1, [W14+3]
0012C6  90402E     MOV.B [W14+2], W0
0012C8  FB8000     ZE W0, W0
0012CA  DD0044     SL W0, #4, W0
0012CC  784080     MOV.B W0, W1
0012CE  90403E     MOV.B [W14+3], W0
0012D0  70C000     IOR.B W1, W0, W0
0012D2  B3CD51     MOV.B #0xD5, W1
0012D4  784F01     MOV.B W1, [W14]
0012D6  984710     MOV.B W0, [W14+1]
0012D8  B3C021     MOV.B #0x2, W1
0012DA  78000E     MOV W14, W0
0012DC  07FEB3     RCALL _ssd1306_sendCMD
0012DE  FA8000     ULNK
0012E0  060000     RETURN
0012E2  FA0004     LNK #0x4
0012E4  984720     MOV.B W0, [W14+2]
0012E6  B3CD90     MOV.B #0xD9, W0
0012E8  784F00     MOV.B W0, [W14]
0012EA  9040AE     MOV.B [W14+2], W1
0012EC  984711     MOV.B W1, [W14+1]
0012EE  B3C021     MOV.B #0x2, W1
0012F0  78000E     MOV W14, W0
0012F2  07FEA8     RCALL _ssd1306_sendCMD
0012F4  FA8000     ULNK
0012F6  060000     RETURN
0012F8  FA0004     LNK #0x4
0012FA  984720     MOV.B W0, [W14+2]
0012FC  B3CDB0     MOV.B #0xDB, W0
0012FE  784F00     MOV.B W0, [W14]
001300  9040AE     MOV.B [W14+2], W1
001302  984711     MOV.B W1, [W14+1]
001304  B3C021     MOV.B #0x2, W1
001306  78000E     MOV W14, W0
001308  07FE9D     RCALL _ssd1306_sendCMD
00130A  FA8000     ULNK
00130C  060000     RETURN
00130E  FA0002     LNK #0x2
001310  B3CE30     MOV.B #0xE3, W0
001312  784F00     MOV.B W0, [W14]
001314  B3C011     MOV.B #0x1, W1
001316  78000E     MOV W14, W0
001318  07FE95     RCALL _ssd1306_sendCMD
00131A  FA8000     ULNK
00131C  060000     RETURN
00131E  FA0004     LNK #0x4
001320  984720     MOV.B W0, [W14+2]
001322  B3C8D0     MOV.B #0x8D, W0
001324  784F00     MOV.B W0, [W14]
001326  9040AE     MOV.B [W14+2], W1
001328  984711     MOV.B W1, [W14+1]
00132A  B3C021     MOV.B #0x2, W1
00132C  78000E     MOV W14, W0
00132E  07FE8A     RCALL _ssd1306_sendCMD
001330  FA8000     ULNK
001332  060000     RETURN
001334  FA0000     LNK #0x0
001336  220AC0     MOV #0x20AC, W0
001338  881200     MOV W0, SPI1STAT
00133A  2013E0     MOV #0x13E, W0
00133C  881210     MOV W0, SPI1CON1
00133E  EF2244     CLR SPI1CON2
001340  A94085     BCLR 0x85, #2
001342  800540     MOV IPC2, W0
001344  A18000     BCLR W0, #8
001346  A19000     BCLR W0, #9
001348  A1A000     BCLR W0, #10
00134A  880540     MOV W0, IPC2
00134C  A8E241     BSET 0x241, #7
00134E  FA8000     ULNK
001350  060000     RETURN
68:                
69:                void ssd1306_send(uint8_t* data, uint16_t dataSize)
70:                {
001074  FA0006     LNK #0x6
71:                    uint16_t i;
72:                
73:                    OLED_DC = 1;
00107A  A8C2CD     BSET 0x2CD, #6
74:                    OLED_CS = 0;
00107C  A9E2CD     BCLR 0x2CD, #7
75:                
76:                    for (i = 0; i < dataSize; i++, data++)
00107E  EB0000     CLR W0
001080  780F00     MOV W0, [W14]
001082  370007     BRA 0x1092
00108A  E80F1E     INC [W14], [W14]
00108C  90001E     MOV [W14+2], W0
00108E  E80000     INC W0, W0
001090  980710     MOV W0, [W14+2]
001092  90002E     MOV [W14+4], W0
001094  78009E     MOV [W14], W1
001096  508F80     SUB W1, W0, [W15]
001098  39FFF5     BRA NC, 0x1084
77:                    {
78:                        spiTransferByte(*data);
001084  90001E     MOV [W14+2], W0
001086  784010     MOV.B [W0], W0
001088  070665     RCALL spiTransferByte
79:                    }
80:                
81:                    Nop();
00109A  000000     NOP
82:                    Nop();
00109C  000000     NOP
83:                    OLED_CS = 1;
00109E  A8E2CD     BSET 0x2CD, #7
84:                }
0010A0  FA8000     ULNK
0010A2  060000     RETURN
85:                
86:                /* Command functions **********************************************************/
87:                void ssd1306cmd_contrast(uint8_t contrast)
88:                {
0010A4  FA0004     LNK #0x4
0010A6  984720     MOV.B W0, [W14+2]
89:                    uint8_t cmd[] = {SSD1306_SET_CONTRAST, contrast};
0010A8  B3C810     MOV.B #0x81, W0
0010AA  784F00     MOV.B W0, [W14]
0010AC  9040AE     MOV.B [W14+2], W1
0010AE  984711     MOV.B W1, [W14+1]
90:                    ssd1306_sendCMD(cmd, 2);
0010B0  B3C021     MOV.B #0x2, W1
0010B2  78000E     MOV W14, W0
0010B4  07FFC7     RCALL _ssd1306_sendCMD
91:                }
0010B6  FA8000     ULNK
0010B8  060000     RETURN
92:                
93:                void ssd1306cmd_entireDisplayOn(uint8_t resume_on)
94:                {
0010BA  FA0004     LNK #0x4
0010BC  984720     MOV.B W0, [W14+2]
95:                    uint8_t cmd[] = {SSD1306_ENTIRE_DISPLAYALL_ON | resume_on};
0010BE  9040AE     MOV.B [W14+2], W1
0010C0  B3CA40     MOV.B #0xA4, W0
0010C2  70C000     IOR.B W1, W0, W0
0010C4  784F00     MOV.B W0, [W14]
96:                    ssd1306_sendCMD(cmd, 1);
0010C6  B3C011     MOV.B #0x1, W1
0010C8  78000E     MOV W14, W0
0010CA  07FFBC     RCALL _ssd1306_sendCMD
97:                }
0010CC  FA8000     ULNK
0010CE  060000     RETURN
0010D0  FA0004     LNK #0x4
0010D2  984720     MOV.B W0, [W14+2]
98:                
99:                void ssd1306cmd_displayNormalInverse(uint8_t norm_inv)
100:               {
0010D0  FA0004     LNK #0x4
101:                   uint8_t cmd[] = {SSD1306_NORM_INV_DISPLAY | norm_inv};
0010D4  9040AE     MOV.B [W14+2], W1
0010D6  B3CA60     MOV.B #0xA6, W0
0010D8  70C000     IOR.B W1, W0, W0
0010DA  784F00     MOV.B W0, [W14]
102:                   ssd1306_sendCMD(cmd, 1);
0010DC  B3C011     MOV.B #0x1, W1
0010DE  78000E     MOV W14, W0
0010E0  07FFB1     RCALL _ssd1306_sendCMD
103:               }
0010E2  FA8000     ULNK
0010E4  060000     RETURN
0010E6  FA0004     LNK #0x4
0010E8  984720     MOV.B W0, [W14+2]
104:               
105:               void ssd1306cmd_displayOnOff(uint8_t on_off)
106:               {
0010E6  FA0004     LNK #0x4
107:                   uint8_t cmd[] = {SSD1306_DISPLAY_ON_OFF | on_off};
0010EA  9040AE     MOV.B [W14+2], W1
0010EC  B3CAE0     MOV.B #0xAE, W0
0010EE  70C000     IOR.B W1, W0, W0
0010F0  784F00     MOV.B W0, [W14]
108:                   ssd1306_sendCMD(cmd, 1);
0010F2  B3C011     MOV.B #0x1, W1
0010F4  78000E     MOV W14, W0
0010F6  07FFA6     RCALL _ssd1306_sendCMD
109:               }
0010F8  FA8000     ULNK
0010FA  060000     RETURN
0010FC  FA000C     LNK #0xC
0010FE  984F00     MOV.B W0, [W14+8]
001100  984F11     MOV.B W1, [W14+9]
001102  984F22     MOV.B W2, [W14+10]
001104  984F33     MOV.B W3, [W14+11]
110:               
111:               void ssd1306cmd_scrollHorizontal(uint8_t dir, uint8_t start, uint8_t time, uint8_t end)
112:               {
0010FC  FA000C     LNK #0xC
113:                   uint8_t cmd[] = {(SSD1306_HORIZONTAL_SCROLL | dir), 0x00, start, time, end, 0x00, 0xFF};
001106  90488E     MOV.B [W14+8], W1
001108  B3C260     MOV.B #0x26, W0
00110A  70C000     IOR.B W1, W0, W0
00110C  784F00     MOV.B W0, [W14]
00110E  EB4000     CLR.B W0
001110  984710     MOV.B W0, [W14+1]
001112  90489E     MOV.B [W14+9], W1
001114  984721     MOV.B W1, [W14+2]
001116  9048AE     MOV.B [W14+10], W1
001118  984731     MOV.B W1, [W14+3]
00111A  9048BE     MOV.B [W14+11], W1
00111C  984741     MOV.B W1, [W14+4]
00111E  EB4000     CLR.B W0
001120  984750     MOV.B W0, [W14+5]
001122  EBC000     SETM.B W0
001124  984760     MOV.B W0, [W14+6]
114:                   ssd1306_sendCMD(cmd, 7);
001126  B3C071     MOV.B #0x7, W1
001128  78000E     MOV W14, W0
00112A  07FF8C     RCALL _ssd1306_sendCMD
115:               }
00112C  FA8000     ULNK
00112E  060000     RETURN
116:               void ssd1306cmd_scrollVerticalAndHorizontal(uint8_t dir, uint8_t start, uint8_t time, uint8_t end, uint8_t offset)
117:               {
001130  FA000C     LNK #0xC
001132  984760     MOV.B W0, [W14+6]
001134  984771     MOV.B W1, [W14+7]
001136  984F02     MOV.B W2, [W14+8]
001138  984F13     MOV.B W3, [W14+9]
00113A  984F24     MOV.B W4, [W14+10]
118:                   uint8_t cmd[] = {(SSD1306_VERTICAL_HORIZONTAL_SCROLL | dir), 0x00, start, time, end, offset};
00113C  9040EE     MOV.B [W14+6], W1
00113E  B3C290     MOV.B #0x29, W0
001140  70C000     IOR.B W1, W0, W0
001142  784F00     MOV.B W0, [W14]
001144  EB4000     CLR.B W0
001146  984710     MOV.B W0, [W14+1]
001148  9040FE     MOV.B [W14+7], W1
00114A  984721     MOV.B W1, [W14+2]
00114C  90488E     MOV.B [W14+8], W1
00114E  984731     MOV.B W1, [W14+3]
001150  90489E     MOV.B [W14+9], W1
001152  984741     MOV.B W1, [W14+4]
001154  9048AE     MOV.B [W14+10], W1
001156  984751     MOV.B W1, [W14+5]
119:                   ssd1306_sendCMD(cmd, 7);
001158  B3C071     MOV.B #0x7, W1
00115A  78000E     MOV W14, W0
00115C  07FF73     RCALL _ssd1306_sendCMD
120:               }
00115E  FA8000     ULNK
001160  060000     RETURN
121:               void ssd1306cmd_scrollOn(void)
122:               {
001162  FA0002     LNK #0x2
123:                   uint8_t cmd[] = {SSD1306_ACTIVATE_SCROLL};
001164  B3C2F0     MOV.B #0x2F, W0
001166  784F00     MOV.B W0, [W14]
124:                   ssd1306_sendCMD(cmd, 1);
001168  B3C011     MOV.B #0x1, W1
00116A  78000E     MOV W14, W0
00116C  07FF6B     RCALL _ssd1306_sendCMD
125:               }
00116E  FA8000     ULNK
001170  060000     RETURN
126:               void ssd1306cmd_scrollOff(void)
127:               {
001172  FA0002     LNK #0x2
128:                   uint8_t cmd[] = {SSD1306_DEACTIVATE_SCROLL};
001174  B3C2E0     MOV.B #0x2E, W0
001176  784F00     MOV.B W0, [W14]
129:                   ssd1306_sendCMD(cmd, 1);
001178  B3C011     MOV.B #0x1, W1
00117A  78000E     MOV W14, W0
00117C  07FF63     RCALL _ssd1306_sendCMD
130:               }
00117E  FA8000     ULNK
001180  060000     RETURN
131:               void ssd1306cmd_scrollVerticalarea(uint8_t rowsFixed, uint8_t rowsScroll)
132:               {
001182  FA0006     LNK #0x6
001184  984740     MOV.B W0, [W14+4]
001186  984751     MOV.B W1, [W14+5]
133:                   uint8_t cmd[] = {SSD1306_SET_VERTICAL_SCROLL_AREA, rowsFixed, rowsScroll};
001188  B3CA30     MOV.B #0xA3, W0
00118A  784F00     MOV.B W0, [W14]
00118C  9040CE     MOV.B [W14+4], W1
00118E  984711     MOV.B W1, [W14+1]
001190  9040DE     MOV.B [W14+5], W1
001192  984721     MOV.B W1, [W14+2]
134:                   ssd1306_sendCMD(cmd, 3);
001194  B3C031     MOV.B #0x3, W1
001196  78000E     MOV W14, W0
001198  07FF55     RCALL _ssd1306_sendCMD
135:               }
00119A  FA8000     ULNK
00119C  060000     RETURN
136:               
137:               void ssd1306cmd_addrLowerColumn(uint8_t lowerNibble)
138:               {
00119E  FA0004     LNK #0x4
0011A0  984720     MOV.B W0, [W14+2]
139:                   uint8_t cmd[] = { SSD1306_SET_LOW_COLUMN | (lowerNibble & 0x0F) };
0011A2  90402E     MOV.B [W14+2], W0
0011A4  60406F     AND.B W0, #0xF, W0
0011A6  784F00     MOV.B W0, [W14]
140:                   ssd1306_sendCMD(cmd, 1);
0011A8  B3C011     MOV.B #0x1, W1
0011AA  78000E     MOV W14, W0
0011AC  07FF4B     RCALL _ssd1306_sendCMD
141:               }
0011AE  FA8000     ULNK
0011B0  060000     RETURN
142:               void ssd1306cmd_addrHigherColumn(uint8_t higherNibble)
143:               {
0011B2  FA0004     LNK #0x4
0011B4  984720     MOV.B W0, [W14+2]
144:                   uint8_t cmd[] = { SSD1306_SET_HIGH_COLUMN | (higherNibble & 0x0F) };
0011B6  90402E     MOV.B [W14+2], W0
0011B8  60406F     AND.B W0, #0xF, W0
0011BA  A04400     BSET.B W0, #4
0011BC  784F00     MOV.B W0, [W14]
145:                   ssd1306_sendCMD(cmd, 1);
0011BE  B3C011     MOV.B #0x1, W1
0011C0  78000E     MOV W14, W0
0011C2  07FF40     RCALL _ssd1306_sendCMD
146:               }
0011C4  FA8000     ULNK
0011C6  060000     RETURN
0011C8  FA0004     LNK #0x4
0011CA  984720     MOV.B W0, [W14+2]
147:               void ssd1306cmd_addrMemoryAddressingMode(uint8_t mode)
148:               {
0011C8  FA0004     LNK #0x4
149:                   uint8_t cmd[] = {SSD1306_SET_MEMORY_MODE, (mode & 0x02)};
0011CC  90402E     MOV.B [W14+2], W0
0011CE  604062     AND.B W0, #0x2, W0
0011D0  B3C201     MOV.B #0x20, W1
0011D2  784F01     MOV.B W1, [W14]
0011D4  984710     MOV.B W0, [W14+1]
150:                   ssd1306_sendCMD(cmd, 2);
0011D6  B3C021     MOV.B #0x2, W1
0011D8  78000E     MOV W14, W0
0011DA  07FF34     RCALL _ssd1306_sendCMD
151:               }
0011DC  FA8000     ULNK
0011DE  060000     RETURN
0011E0  FA0006     LNK #0x6
0011E2  984740     MOV.B W0, [W14+4]
0011E4  984751     MOV.B W1, [W14+5]
152:               void ssd1306cmd_addrColumnAddress(uint8_t startAddress, uint8_t endAddress)
153:               {
0011E0  FA0006     LNK #0x6
154:                   uint8_t cmd[] = {SSD1306_SET_COLUMN_ADDR, (startAddress & 0x7F), (endAddress & 0x7F)};
0011E6  90404E     MOV.B [W14+4], W0
0011E8  784080     MOV.B W0, W1
0011EA  A17401     BCLR.B W1, #7
0011EC  90405E     MOV.B [W14+5], W0
0011EE  A17400     BCLR.B W0, #7
0011F0  B3C212     MOV.B #0x21, W2
0011F2  784F02     MOV.B W2, [W14]
0011F4  984711     MOV.B W1, [W14+1]
0011F6  984720     MOV.B W0, [W14+2]
155:                   ssd1306_sendCMD(cmd, 3);
0011F8  B3C031     MOV.B #0x3, W1
0011FA  78000E     MOV W14, W0
0011FC  07FF23     RCALL _ssd1306_sendCMD
156:               }
0011FE  FA8000     ULNK
001200  060000     RETURN
157:               void ssd1306cmd_addrPageAddress(uint8_t startAddress, uint8_t endAddress)
158:               {
001202  FA0006     LNK #0x6
001204  984740     MOV.B W0, [W14+4]
001206  984751     MOV.B W1, [W14+5]
159:                   uint8_t cmd[] = {SSD1306_SET_PAGE_ADDR, (startAddress & 0x07), (endAddress & 0x07)};
001208  90404E     MOV.B [W14+4], W0
00120A  6040E7     AND.B W0, #0x7, W1
00120C  90405E     MOV.B [W14+5], W0
00120E  604067     AND.B W0, #0x7, W0
001210  B3C222     MOV.B #0x22, W2
001212  784F02     MOV.B W2, [W14]
001214  984711     MOV.B W1, [W14+1]
001216  984720     MOV.B W0, [W14+2]
160:                   ssd1306_sendCMD(cmd, 3);
001218  B3C031     MOV.B #0x3, W1
00121A  78000E     MOV W14, W0
00121C  07FF13     RCALL _ssd1306_sendCMD
161:               }
00121E  FA8000     ULNK
001220  060000     RETURN
001222  FA0004     LNK #0x4
001224  984720     MOV.B W0, [W14+2]
162:               void ssd1306cmd_addrPageStartAddress(uint8_t startAddress)
163:               {
001222  FA0004     LNK #0x4
164:                   uint8_t cmd[] = {SSD1306_SET_PAGE_START_ADDR | startAddress};
001226  9040AE     MOV.B [W14+2], W1
001228  B3CB00     MOV.B #0xB0, W0
00122A  70C000     IOR.B W1, W0, W0
00122C  784F00     MOV.B W0, [W14]
165:                   ssd1306_sendCMD(cmd, 1);
00122E  B3C011     MOV.B #0x1, W1
001230  78000E     MOV W14, W0
001232  07FF08     RCALL _ssd1306_sendCMD
166:               }
001234  FA8000     ULNK
001236  060000     RETURN
167:               
168:               void ssd1306cmd_displayStartLine(uint8_t startLineReg)
169:               {
001238  FA0004     LNK #0x4
00123A  984720     MOV.B W0, [W14+2]
170:                   uint8_t cmd[] = {SSD1306_SET_START_LINE | startLineReg};
00123C  9040AE     MOV.B [W14+2], W1
00123E  B3C400     MOV.B #0x40, W0
001240  70C000     IOR.B W1, W0, W0
001242  784F00     MOV.B W0, [W14]
171:                   ssd1306_sendCMD(cmd, 1);
001244  B3C011     MOV.B #0x1, W1
001246  78000E     MOV W14, W0
001248  07FEFD     RCALL _ssd1306_sendCMD
172:               }
00124A  FA8000     ULNK
00124C  060000     RETURN
00124E  FA0004     LNK #0x4
001250  984720     MOV.B W0, [W14+2]
173:               void ssd1306cmd_displaySegmentRemap(uint8_t addr)
174:               {
00124E  FA0004     LNK #0x4
175:                   uint8_t cmd[] = {SSD1306_SET_SEGMENT_REMAP | addr};
001252  9040AE     MOV.B [W14+2], W1
001254  B3CA00     MOV.B #0xA0, W0
001256  70C000     IOR.B W1, W0, W0
001258  784F00     MOV.B W0, [W14]
176:                   ssd1306_sendCMD(cmd, 1);
00125A  B3C011     MOV.B #0x1, W1
00125C  78000E     MOV W14, W0
00125E  07FEF2     RCALL _ssd1306_sendCMD
177:               }
001260  FA8000     ULNK
001262  060000     RETURN
001264  FA0004     LNK #0x4
001266  984720     MOV.B W0, [W14+2]
178:               void ssd1306cmd_displayMultiplexRatio(uint8_t ratio)
179:               {
001264  FA0004     LNK #0x4
180:                   uint8_t cmd[] = {SSD1306_SET_MULTIPLEX, (ratio & 0x3F)};
001268  90402E     MOV.B [W14+2], W0
00126A  B243F0     AND.B #0x3F, W0
00126C  B3CA81     MOV.B #0xA8, W1
00126E  784F01     MOV.B W1, [W14]
001270  984710     MOV.B W0, [W14+1]
181:                   ssd1306_sendCMD(cmd, 2);
001272  B3C021     MOV.B #0x2, W1
001274  78000E     MOV W14, W0
001276  07FEE6     RCALL _ssd1306_sendCMD
182:               }
001278  FA8000     ULNK
00127A  060000     RETURN
00127C  FA0004     LNK #0x4
00127E  984720     MOV.B W0, [W14+2]
183:               void ssd1306cmd_displayComDirection(uint8_t dir)
184:               {
00127C  FA0004     LNK #0x4
185:                   uint8_t cmd[] = {SSD1306_COM_SCAN | dir};
001280  9040AE     MOV.B [W14+2], W1
001282  B3CC00     MOV.B #0xC0, W0
001284  70C000     IOR.B W1, W0, W0
001286  784F00     MOV.B W0, [W14]
186:                   ssd1306_sendCMD(cmd, 1);
001288  B3C011     MOV.B #0x1, W1
00128A  78000E     MOV W14, W0
00128C  07FEDB     RCALL _ssd1306_sendCMD
187:               }
00128E  FA8000     ULNK
001290  060000     RETURN
188:               void ssd1306cmd_displayOffset(uint8_t offset)
189:               {
001292  FA0004     LNK #0x4
001294  984720     MOV.B W0, [W14+2]
190:                   uint8_t cmd[] = {SSD1306_SET_DISPLAY_OFFSET, (offset & 0x3F)};
001296  90402E     MOV.B [W14+2], W0
001298  B243F0     AND.B #0x3F, W0
00129A  B3CD31     MOV.B #0xD3, W1
00129C  784F01     MOV.B W1, [W14]
00129E  984710     MOV.B W0, [W14+1]
191:                   ssd1306_sendCMD(cmd, 2);
0012A0  B3C021     MOV.B #0x2, W1
0012A2  78000E     MOV W14, W0
0012A4  07FECF     RCALL _ssd1306_sendCMD
192:               }
0012A6  FA8000     ULNK
0012A8  060000     RETURN
193:               void ssd1306cmd_displayComPins(uint8_t config)
194:               {
0012AA  FA0004     LNK #0x4
0012AC  984720     MOV.B W0, [W14+2]
195:                   uint8_t cmd[] = {SSD1306_SET_COM_PINS, config};
0012AE  B3CDA0     MOV.B #0xDA, W0
0012B0  784F00     MOV.B W0, [W14]
0012B2  9040AE     MOV.B [W14+2], W1
0012B4  984711     MOV.B W1, [W14+1]
196:                   ssd1306_sendCMD(cmd, 2);
0012B6  B3C021     MOV.B #0x2, W1
0012B8  78000E     MOV W14, W0
0012BA  07FEC4     RCALL _ssd1306_sendCMD
197:               }
0012BC  FA8000     ULNK
0012BE  060000     RETURN
198:               
199:               void ssd1306cmd_setClock(uint8_t ratio, uint8_t freq)
200:               {
0012C0  FA0004     LNK #0x4
0012C2  984720     MOV.B W0, [W14+2]
0012C4  984731     MOV.B W1, [W14+3]
201:                   uint8_t cmd[] = {SSD1306_SET_DISPLAY_CLOCK_DIV, ((ratio << 4) | freq)};
0012C6  90402E     MOV.B [W14+2], W0
0012C8  FB8000     ZE W0, W0
0012CA  DD0044     SL W0, #4, W0
0012CC  784080     MOV.B W0, W1
0012CE  90403E     MOV.B [W14+3], W0
0012D0  70C000     IOR.B W1, W0, W0
0012D2  B3CD51     MOV.B #0xD5, W1
0012D4  784F01     MOV.B W1, [W14]
0012D6  984710     MOV.B W0, [W14+1]
202:                   ssd1306_sendCMD(cmd, 2);
0012D8  B3C021     MOV.B #0x2, W1
0012DA  78000E     MOV W14, W0
0012DC  07FEB3     RCALL _ssd1306_sendCMD
203:               }
0012DE  FA8000     ULNK
0012E0  060000     RETURN
0012E2  FA0004     LNK #0x4
0012E4  984720     MOV.B W0, [W14+2]
204:               void ssd1306cmd_setPrechargePeriod(uint8_t phase)
205:               {
0012E2  FA0004     LNK #0x4
206:                   uint8_t cmd[] = {SSD1306_SET_PRECHARGE, phase};
0012E6  B3CD90     MOV.B #0xD9, W0
0012E8  784F00     MOV.B W0, [W14]
0012EA  9040AE     MOV.B [W14+2], W1
0012EC  984711     MOV.B W1, [W14+1]
207:                   ssd1306_sendCMD(cmd, 2);
0012EE  B3C021     MOV.B #0x2, W1
0012F0  78000E     MOV W14, W0
0012F2  07FEA8     RCALL _ssd1306_sendCMD
208:               }
0012F4  FA8000     ULNK
0012F6  060000     RETURN
0012F8  FA0004     LNK #0x4
0012FA  984720     MOV.B W0, [W14+2]
209:               void ssd1306cmd_setVDeselect(uint8_t level)
210:               {
0012F8  FA0004     LNK #0x4
211:                   uint8_t cmd[] = {SSD1306_SET_VCOM_DESELECT, level};
0012FC  B3CDB0     MOV.B #0xDB, W0
0012FE  784F00     MOV.B W0, [W14]
001300  9040AE     MOV.B [W14+2], W1
001302  984711     MOV.B W1, [W14+1]
212:                   ssd1306_sendCMD(cmd, 2);
001304  B3C021     MOV.B #0x2, W1
001306  78000E     MOV W14, W0
001308  07FE9D     RCALL _ssd1306_sendCMD
213:               }
00130A  FA8000     ULNK
00130C  060000     RETURN
214:               void ssd1306cmd_nop(void)
215:               {
00130E  FA0002     LNK #0x2
216:                   uint8_t cmd[] = {SSD1306_NOP};
001310  B3CE30     MOV.B #0xE3, W0
001312  784F00     MOV.B W0, [W14]
217:                   ssd1306_sendCMD(cmd, 1);
001314  B3C011     MOV.B #0x1, W1
001316  78000E     MOV W14, W0
001318  07FE95     RCALL _ssd1306_sendCMD
218:               }
00131A  FA8000     ULNK
00131C  060000     RETURN
219:               
220:               void ssd1306cmd_chargePump(uint8_t arg)
221:               {
00131E  FA0004     LNK #0x4
001320  984720     MOV.B W0, [W14+2]
222:                   uint8_t cmd[] = {SSD1306_CHARGE_PUMP ,arg};
001322  B3C8D0     MOV.B #0x8D, W0
001324  784F00     MOV.B W0, [W14]
001326  9040AE     MOV.B [W14+2], W1
001328  984711     MOV.B W1, [W14+1]
223:                   ssd1306_sendCMD(cmd, 2);
00132A  B3C021     MOV.B #0x2, W1
00132C  78000E     MOV W14, W0
00132E  07FE8A     RCALL _ssd1306_sendCMD
224:               }
001330  FA8000     ULNK
001332  060000     RETURN
225:               
226:               void ssd1306_init()
227:               {
001334  FA0000     LNK #0x0
228:                   
229:                   //RAZOBRATISIA
230:                       SPI1STAT = 0x20AC;
001336  220AC0     MOV #0x20AC, W0
001338  881200     MOV W0, SPI1STAT
231:                   SPI1CON1 = 0x013E;
00133A  2013E0     MOV #0x13E, W0
00133C  881210     MOV W0, SPI1CON1
232:                   SPI1CON2 = 0x0000;
00133E  EF2244     CLR SPI1CON2
233:                   SPI1_INTERRUPT_CLEAR;
001340  A94085     BCLR 0x85, #2
234:                   SPI1_INTERRUPT_PRIORITY = INTERRUPT_PRIORITY_DISABLED;
001342  800540     MOV IPC2, W0
001344  A18000     BCLR W0, #8
001346  A19000     BCLR W0, #9
001348  A1A000     BCLR W0, #10
00134A  880540     MOV W0, IPC2
235:                   SPI1_ENABLE;
00134C  A8E241     BSET 0x241, #7
236:                   //spi_init();
237:               }
00134E  FA8000     ULNK
001350  060000     RETURN
001352  FA0000     LNK #0x0
